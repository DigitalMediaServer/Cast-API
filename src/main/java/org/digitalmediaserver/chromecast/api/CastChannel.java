// Generated by the protocol buffer compiler. DO NOT EDIT!
// source: src/main/resources/cast_channel.proto

package org.digitalmediaserver.chromecast.api;

import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectStreamException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import com.google.protobuf.AbstractMessageLite;
import com.google.protobuf.AbstractParser;
import com.google.protobuf.ByteString;
import com.google.protobuf.CodedInputStream;
import com.google.protobuf.CodedOutputStream;
import com.google.protobuf.ExtensionRegistryLite;
import com.google.protobuf.GeneratedMessageLite;
import com.google.protobuf.Internal;
import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.MessageLiteOrBuilder;
import com.google.protobuf.Parser;

final class CastChannel {

	private CastChannel() {
	}

	public static void registerAllExtensions(ExtensionRegistryLite registry) {
	}

	/**
	 * Protobuf enum
	 * {@code SignatureAlgorithm}
	 */
	public enum SignatureAlgorithm implements Internal.EnumLite {

		/**
		 * <code>UNSPECIFIED = 0;</code>
		 */
		UNSPECIFIED(0, 0),
		/**
		 * <code>RSASSA_PKCS1v15 = 1;</code>
		 */
		RSASSA_PKCS1v15(1, 1),
		/**
		 * <code>RSASSA_PSS = 2;</code>
		 */
		RSASSA_PSS(2, 2),;

		/**
		 * <code>UNSPECIFIED = 0;</code>
		 */
		public static final int UNSPECIFIED_VALUE = 0;
		/**
		 * <code>RSASSA_PKCS1v15 = 1;</code>
		 */
		public static final int RSASSA_PKCS1v15_VALUE = 1;
		/**
		 * <code>RSASSA_PSS = 2;</code>
		 */
		public static final int RSASSA_PSS_VALUE = 2;

		@Override
		public final int getNumber() {
			return value;
		}

		public static SignatureAlgorithm valueOf(int value) {
			switch (value) {
				case 0:
					return UNSPECIFIED;
				case 1:
					return RSASSA_PKCS1v15;
				case 2:
					return RSASSA_PSS;
				default:
					return null;
			}
		}

		public static Internal.EnumLiteMap<SignatureAlgorithm> internalGetValueMap() {
			return internalValueMap;
		}

		private static Internal.EnumLiteMap<SignatureAlgorithm> internalValueMap = new Internal.EnumLiteMap<SignatureAlgorithm>() {

			@Override
			public SignatureAlgorithm findValueByNumber(int number) {
				return SignatureAlgorithm.valueOf(number);
			}
		};

		private final int value;

		private SignatureAlgorithm(int index, int value) {
			this.value = value;
		}

		// @@protoc_insertion_point(enum_scope:SignatureAlgorithm)
	}

	public interface CastMessageOrBuilder extends
		// @@protoc_insertion_point(interface_extends:CastMessage)
		MessageLiteOrBuilder {

		/**
		 * <code>required .CastMessage.ProtocolVersion protocol_version = 1;</code>
		 */
		boolean hasProtocolVersion();

		/**
		 * <code>required .CastMessage.ProtocolVersion protocol_version = 1;</code>
		 */
		CastChannel.CastMessage.ProtocolVersion getProtocolVersion();

		/**
		 * <code>required string source_id = 2;</code>
		 *
		 * <pre>
		 * source and destination ids identify the origin and destination of the
		 * message.  They are used to route messages between endpoints that share a
		 * device-to-device channel.
		 * For messages between applications:
		 *   - The sender application id is a unique identifier generated on behalf of
		 *     the sender application.
		 *   - The receiver id is always the the session id for the application.
		 * For messages to or from the sender or receiver platform, the special ids
		 * 'sender-0' and 'receiver-0' can be used.
		 * For messages intended for all endpoints using a given channel, the
		 * wildcard destination_id '*' can be used.
		 * </pre>
		 */
		boolean hasSourceId();

		/**
		 * <code>required string source_id = 2;</code>
		 *
		 * <pre>
		 * source and destination ids identify the origin and destination of the
		 * message.  They are used to route messages between endpoints that share a
		 * device-to-device channel.
		 * For messages between applications:
		 *   - The sender application id is a unique identifier generated on behalf of
		 *     the sender application.
		 *   - The receiver id is always the the session id for the application.
		 * For messages to or from the sender or receiver platform, the special ids
		 * 'sender-0' and 'receiver-0' can be used.
		 * For messages intended for all endpoints using a given channel, the
		 * wildcard destination_id '*' can be used.
		 * </pre>
		 */
		String getSourceId();

		/**
		 * <code>required string source_id = 2;</code>
		 *
		 * <pre>
		 * source and destination ids identify the origin and destination of the
		 * message.  They are used to route messages between endpoints that share a
		 * device-to-device channel.
		 * For messages between applications:
		 *   - The sender application id is a unique identifier generated on behalf of
		 *     the sender application.
		 *   - The receiver id is always the the session id for the application.
		 * For messages to or from the sender or receiver platform, the special ids
		 * 'sender-0' and 'receiver-0' can be used.
		 * For messages intended for all endpoints using a given channel, the
		 * wildcard destination_id '*' can be used.
		 * </pre>
		 */
		ByteString getSourceIdBytes();

		/**
		 * <code>required string destination_id = 3;</code>
		 */
		boolean hasDestinationId();

		/**
		 * <code>required string destination_id = 3;</code>
		 */
		String getDestinationId();

		/**
		 * <code>required string destination_id = 3;</code>
		 */
		ByteString getDestinationIdBytes();

		/**
		 * <code>required string namespace = 4;</code>
		 *
		 * <pre>
		 * This is the core multiplexing key.  All messages are sent on a namespace
		 * and endpoints sharing a channel listen on one or more namespaces.  The
		 * namespace defines the protocol and semantics of the message.
		 * </pre>
		 */
		boolean hasNamespace();

		/**
		 * <code>required string namespace = 4;</code>
		 *
		 * <pre>
		 * This is the core multiplexing key.  All messages are sent on a namespace
		 * and endpoints sharing a channel listen on one or more namespaces.  The
		 * namespace defines the protocol and semantics of the message.
		 * </pre>
		 */
		String getNamespace();

		/**
		 * <code>required string namespace = 4;</code>
		 *
		 * <pre>
		 * This is the core multiplexing key.  All messages are sent on a namespace
		 * and endpoints sharing a channel listen on one or more namespaces.  The
		 * namespace defines the protocol and semantics of the message.
		 * </pre>
		 */
		ByteString getNamespaceBytes();

		/**
		 * <code>required .CastMessage.PayloadType payload_type = 5;</code>
		 */
		boolean hasPayloadType();

		/**
		 * <code>required .CastMessage.PayloadType payload_type = 5;</code>
		 */
		CastChannel.CastMessage.PayloadType getPayloadType();

		/**
		 * <code>optional string payload_utf8 = 6;</code>
		 *
		 * <pre>
		 * Depending on payload_type, exactly one of the following optional fields
		 * will always be set.
		 * </pre>
		 */
		boolean hasPayloadUtf8();

		/**
		 * <code>optional string payload_utf8 = 6;</code>
		 *
		 * <pre>
		 * Depending on payload_type, exactly one of the following optional fields
		 * will always be set.
		 * </pre>
		 */
		String getPayloadUtf8();

		/**
		 * <code>optional string payload_utf8 = 6;</code>
		 *
		 * <pre>
		 * Depending on payload_type, exactly one of the following optional fields
		 * will always be set.
		 * </pre>
		 */
		ByteString getPayloadUtf8Bytes();

		/**
		 * <code>optional bytes payload_binary = 7;</code>
		 */
		boolean hasPayloadBinary();

		/**
		 * <code>optional bytes payload_binary = 7;</code>
		 */
		ByteString getPayloadBinary();
	}

	/**
	 * Protobuf type {@code CastMessage}
	 */
	public static final class CastMessage extends GeneratedMessageLite implements
		// @@protoc_insertion_point(message_implements:CastMessage)
		CastMessageOrBuilder {

		// Use CastMessage.newBuilder() to construct.
		private CastMessage(GeneratedMessageLite.Builder<?, ?> builder) {
			super(builder);
			this.unknownFields = builder.getUnknownFields();
		}

		private CastMessage(boolean noInit) {
			this.unknownFields = ByteString.EMPTY;
		}

		private static final CastMessage defaultInstance;

		public static CastMessage getDefaultInstance() {
			return defaultInstance;
		}

		@Override
		public CastMessage getDefaultInstanceForType() {
			return defaultInstance;
		}

		private final ByteString unknownFields;

		private CastMessage(CodedInputStream input, ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
			initFields();
			ByteString.Output unknownFieldsOutput = ByteString.newOutput();
			CodedOutputStream unknownFieldsCodedOutput = CodedOutputStream.newInstance(unknownFieldsOutput);
			try {
				boolean done = false;
				while (!done) {
					int tag = input.readTag();
					switch (tag) {
						case 0:
							done = true;
							break;
						default: {
							if (!parseUnknownField(input, unknownFieldsCodedOutput, extensionRegistry, tag)) {
								done = true;
							}
							break;
						}
						case 8: {
							int rawValue = input.readEnum();
							CastChannel.CastMessage.ProtocolVersion value = CastChannel.CastMessage.ProtocolVersion
								.valueOf(rawValue);
							if (value == null) {
								unknownFieldsCodedOutput.writeRawVarint32(tag);
								unknownFieldsCodedOutput.writeRawVarint32(rawValue);
							} else {
								bitField0_ |= 0x00000001;
								protocolVersion_ = value;
							}
							break;
						}
						case 18: {
							ByteString bs = input.readBytes();
							bitField0_ |= 0x00000002;
							sourceId_ = bs;
							break;
						}
						case 26: {
							ByteString bs = input.readBytes();
							bitField0_ |= 0x00000004;
							destinationId_ = bs;
							break;
						}
						case 34: {
							ByteString bs = input.readBytes();
							bitField0_ |= 0x00000008;
							namespace_ = bs;
							break;
						}
						case 40: {
							int rawValue = input.readEnum();
							CastChannel.CastMessage.PayloadType value = CastChannel.CastMessage.PayloadType
								.valueOf(rawValue);
							if (value == null) {
								unknownFieldsCodedOutput.writeRawVarint32(tag);
								unknownFieldsCodedOutput.writeRawVarint32(rawValue);
							} else {
								bitField0_ |= 0x00000010;
								payloadType_ = value;
							}
							break;
						}
						case 50: {
							ByteString bs = input.readBytes();
							bitField0_ |= 0x00000020;
							payloadUtf8_ = bs;
							break;
						}
						case 58: {
							bitField0_ |= 0x00000040;
							payloadBinary_ = input.readBytes();
							break;
						}
					}
				}
			} catch (InvalidProtocolBufferException e) {
				throw e.setUnfinishedMessage(this);
			} catch (IOException e) {
				throw new InvalidProtocolBufferException(e.getMessage()).setUnfinishedMessage(this);
			} finally {
				try {
					unknownFieldsCodedOutput.flush();
				} catch (IOException e) {
					// Should not happen
				} finally {
					unknownFields = unknownFieldsOutput.toByteString();
				}
				makeExtensionsImmutable();
			}
		}

		public static Parser<CastMessage> PARSER = new AbstractParser<CastMessage>() {

			@Override
			public CastMessage parsePartialFrom(
				CodedInputStream input,
				ExtensionRegistryLite extensionRegistry
			) throws InvalidProtocolBufferException {
				return new CastMessage(input, extensionRegistry);
			}
		};

		@Override
		public Parser<CastMessage> getParserForType() {
			return PARSER;
		}

		/**
		 * Protobuf enum
		 * {@code CastMessage.ProtocolVersion}
		 *
		 * <pre>
		 * Always pass a version of the protocol for future compatibility
		 * requirements.
		 * </pre>
		 */
		public enum ProtocolVersion implements Internal.EnumLite {

			/**
			 * <code>CASTV2_1_0 = 0;</code>
			 */
			CASTV2_1_0(0, 0),;

			/**
			 * <code>CASTV2_1_0 = 0;</code>
			 */
			public static final int CASTV2_1_0_VALUE = 0;

			@Override
			public final int getNumber() {
				return value;
			}

			public static ProtocolVersion valueOf(int value) {
				switch (value) {
					case 0:
						return CASTV2_1_0;
					default:
						return null;
				}
			}

			public static Internal.EnumLiteMap<ProtocolVersion> internalGetValueMap() {
				return internalValueMap;
			}

			private static Internal.EnumLiteMap<ProtocolVersion> internalValueMap = new Internal.EnumLiteMap<ProtocolVersion>() {

				@Override
				public ProtocolVersion findValueByNumber(int number) {
					return ProtocolVersion.valueOf(number);
				}
			};

			private final int value;

			private ProtocolVersion(int index, int value) {
				this.value = value;
			}

			// @@protoc_insertion_point(enum_scope:CastMessage.ProtocolVersion)
		}

		/**
		 * Protobuf enum
		 * {@code CastMessage.PayloadType}
		 *
		 * <pre>
		 * What type of data do we have in this message.
		 * </pre>
		 */
		public enum PayloadType implements Internal.EnumLite {

			/**
			 * <code>STRING = 0;</code>
			 */
			STRING(0, 0),
			/**
			 * <code>BINARY = 1;</code>
			 */
			BINARY(1, 1),;

			/**
			 * <code>STRING = 0;</code>
			 */
			public static final int STRING_VALUE = 0;
			/**
			 * <code>BINARY = 1;</code>
			 */
			public static final int BINARY_VALUE = 1;

			@Override
			public final int getNumber() {
				return value;
			}

			public static PayloadType valueOf(int value) {
				switch (value) {
					case 0:
						return STRING;
					case 1:
						return BINARY;
					default:
						return null;
				}
			}

			public static Internal.EnumLiteMap<PayloadType> internalGetValueMap() {
				return internalValueMap;
			}

			private static Internal.EnumLiteMap<PayloadType> internalValueMap = new Internal.EnumLiteMap<PayloadType>() {

				@Override
				public PayloadType findValueByNumber(int number) {
					return PayloadType.valueOf(number);
				}
			};

			private final int value;

			private PayloadType(int index, int value) {
				this.value = value;
			}

			// @@protoc_insertion_point(enum_scope:CastMessage.PayloadType)
		}

		private int bitField0_;
		public static final int PROTOCOL_VERSION_FIELD_NUMBER = 1;
		private CastChannel.CastMessage.ProtocolVersion protocolVersion_;

		/**
		 * <code>required .CastMessage.ProtocolVersion protocol_version = 1;</code>
		 */
		@Override
		public boolean hasProtocolVersion() {
			return ((bitField0_ & 0x00000001) == 0x00000001);
		}

		/**
		 * <code>required .CastMessage.ProtocolVersion protocol_version = 1;</code>
		 */
		@Override
		public CastChannel.CastMessage.ProtocolVersion getProtocolVersion() {
			return protocolVersion_;
		}

		public static final int SOURCE_ID_FIELD_NUMBER = 2;
		private Object sourceId_;

		/**
		 * <code>required string source_id = 2;</code>
		 *
		 * <pre>
		 * source and destination ids identify the origin and destination of the
		 * message.  They are used to route messages between endpoints that share a
		 * device-to-device channel.
		 * For messages between applications:
		 *   - The sender application id is a unique identifier generated on behalf of
		 *     the sender application.
		 *   - The receiver id is always the the session id for the application.
		 * For messages to or from the sender or receiver platform, the special ids
		 * 'sender-0' and 'receiver-0' can be used.
		 * For messages intended for all endpoints using a given channel, the
		 * wildcard destination_id '*' can be used.
		 * </pre>
		 */
		@Override
		public boolean hasSourceId() {
			return ((bitField0_ & 0x00000002) == 0x00000002);
		}

		/**
		 * <code>required string source_id = 2;</code>
		 *
		 * <pre>
		 * source and destination ids identify the origin and destination of the
		 * message.  They are used to route messages between endpoints that share a
		 * device-to-device channel.
		 * For messages between applications:
		 *   - The sender application id is a unique identifier generated on behalf of
		 *     the sender application.
		 *   - The receiver id is always the the session id for the application.
		 * For messages to or from the sender or receiver platform, the special ids
		 * 'sender-0' and 'receiver-0' can be used.
		 * For messages intended for all endpoints using a given channel, the
		 * wildcard destination_id '*' can be used.
		 * </pre>
		 */
		@Override
		public String getSourceId() {
			Object ref = sourceId_;
			if (ref instanceof String) {
				return (String) ref;
			} else {
				ByteString bs = (ByteString) ref;
				String s = bs.toStringUtf8();
				if (bs.isValidUtf8()) {
					sourceId_ = s;
				}
				return s;
			}
		}

		/**
		 * <code>required string source_id = 2;</code>
		 *
		 * <pre>
		 * source and destination ids identify the origin and destination of the
		 * message.  They are used to route messages between endpoints that share a
		 * device-to-device channel.
		 * For messages between applications:
		 *   - The sender application id is a unique identifier generated on behalf of
		 *     the sender application.
		 *   - The receiver id is always the the session id for the application.
		 * For messages to or from the sender or receiver platform, the special ids
		 * 'sender-0' and 'receiver-0' can be used.
		 * For messages intended for all endpoints using a given channel, the
		 * wildcard destination_id '*' can be used.
		 * </pre>
		 */
		@Override
		public ByteString getSourceIdBytes() {
			Object ref = sourceId_;
			if (ref instanceof String) {
				ByteString b = ByteString.copyFromUtf8((String) ref);
				sourceId_ = b;
				return b;
			} else {
				return (ByteString) ref;
			}
		}

		public static final int DESTINATION_ID_FIELD_NUMBER = 3;
		private Object destinationId_;

		/**
		 * <code>required string destination_id = 3;</code>
		 */
		@Override
		public boolean hasDestinationId() {
			return ((bitField0_ & 0x00000004) == 0x00000004);
		}

		/**
		 * <code>required string destination_id = 3;</code>
		 */
		@Override
		public String getDestinationId() {
			Object ref = destinationId_;
			if (ref instanceof String) {
				return (String) ref;
			} else {
				ByteString bs = (ByteString) ref;
				String s = bs.toStringUtf8();
				if (bs.isValidUtf8()) {
					destinationId_ = s;
				}
				return s;
			}
		}

		/**
		 * <code>required string destination_id = 3;</code>
		 */
		@Override
		public ByteString getDestinationIdBytes() {
			Object ref = destinationId_;
			if (ref instanceof String) {
				ByteString b = ByteString.copyFromUtf8((String) ref);
				destinationId_ = b;
				return b;
			} else {
				return (ByteString) ref;
			}
		}

		public static final int NAMESPACE_FIELD_NUMBER = 4;
		private Object namespace_;

		/**
		 * <code>required string namespace = 4;</code>
		 *
		 * <pre>
		 * This is the core multiplexing key.  All messages are sent on a namespace
		 * and endpoints sharing a channel listen on one or more namespaces.  The
		 * namespace defines the protocol and semantics of the message.
		 * </pre>
		 */
		@Override
		public boolean hasNamespace() {
			return ((bitField0_ & 0x00000008) == 0x00000008);
		}

		/**
		 * <code>required string namespace = 4;</code>
		 *
		 * <pre>
		 * This is the core multiplexing key.  All messages are sent on a namespace
		 * and endpoints sharing a channel listen on one or more namespaces.  The
		 * namespace defines the protocol and semantics of the message.
		 * </pre>
		 */
		@Override
		public String getNamespace() {
			Object ref = namespace_;
			if (ref instanceof String) {
				return (String) ref;
			} else {
				ByteString bs = (ByteString) ref;
				String s = bs.toStringUtf8();
				if (bs.isValidUtf8()) {
					namespace_ = s;
				}
				return s;
			}
		}

		/**
		 * <code>required string namespace = 4;</code>
		 *
		 * <pre>
		 * This is the core multiplexing key.  All messages are sent on a namespace
		 * and endpoints sharing a channel listen on one or more namespaces.  The
		 * namespace defines the protocol and semantics of the message.
		 * </pre>
		 */
		@Override
		public ByteString getNamespaceBytes() {
			Object ref = namespace_;
			if (ref instanceof String) {
				ByteString b = ByteString.copyFromUtf8((String) ref);
				namespace_ = b;
				return b;
			} else {
				return (ByteString) ref;
			}
		}

		public static final int PAYLOAD_TYPE_FIELD_NUMBER = 5;
		private CastChannel.CastMessage.PayloadType payloadType_;

		/**
		 * <code>required .CastMessage.PayloadType payload_type = 5;</code>
		 */
		@Override
		public boolean hasPayloadType() {
			return ((bitField0_ & 0x00000010) == 0x00000010);
		}

		/**
		 * <code>required .CastMessage.PayloadType payload_type = 5;</code>
		 */
		@Override
		public CastChannel.CastMessage.PayloadType getPayloadType() {
			return payloadType_;
		}

		public static final int PAYLOAD_UTF8_FIELD_NUMBER = 6;
		private Object payloadUtf8_;

		/**
		 * <code>optional string payload_utf8 = 6;</code>
		 *
		 * <pre>
		 * Depending on payload_type, exactly one of the following optional fields
		 * will always be set.
		 * </pre>
		 */
		@Override
		public boolean hasPayloadUtf8() {
			return ((bitField0_ & 0x00000020) == 0x00000020);
		}

		/**
		 * <code>optional string payload_utf8 = 6;</code>
		 *
		 * <pre>
		 * Depending on payload_type, exactly one of the following optional fields
		 * will always be set.
		 * </pre>
		 */
		@Override
		public String getPayloadUtf8() {
			Object ref = payloadUtf8_;
			if (ref instanceof String) {
				return (String) ref;
			} else {
				ByteString bs = (ByteString) ref;
				String s = bs.toStringUtf8();
				if (bs.isValidUtf8()) {
					payloadUtf8_ = s;
				}
				return s;
			}
		}

		/**
		 * <code>optional string payload_utf8 = 6;</code>
		 *
		 * <pre>
		 * Depending on payload_type, exactly one of the following optional fields
		 * will always be set.
		 * </pre>
		 */
		@Override
		public ByteString getPayloadUtf8Bytes() {
			Object ref = payloadUtf8_;
			if (ref instanceof String) {
				ByteString b = ByteString.copyFromUtf8((String) ref);
				payloadUtf8_ = b;
				return b;
			} else {
				return (ByteString) ref;
			}
		}

		public static final int PAYLOAD_BINARY_FIELD_NUMBER = 7;
		private ByteString payloadBinary_;

		/**
		 * <code>optional bytes payload_binary = 7;</code>
		 */
		@Override
		public boolean hasPayloadBinary() {
			return ((bitField0_ & 0x00000040) == 0x00000040);
		}

		/**
		 * <code>optional bytes payload_binary = 7;</code>
		 */
		@Override
		public ByteString getPayloadBinary() {
			return payloadBinary_;
		}

		private void initFields() {
			protocolVersion_ = CastChannel.CastMessage.ProtocolVersion.CASTV2_1_0;
			sourceId_ = "";
			destinationId_ = "";
			namespace_ = "";
			payloadType_ = CastChannel.CastMessage.PayloadType.STRING;
			payloadUtf8_ = "";
			payloadBinary_ = ByteString.EMPTY;
		}

		private byte memoizedIsInitialized = -1;

		@Override
		public boolean isInitialized() {
			byte isInitialized = memoizedIsInitialized;
			if (isInitialized == 1)
				return true;
			if (isInitialized == 0)
				return false;

			if (!hasProtocolVersion()) {
				memoizedIsInitialized = 0;
				return false;
			}
			if (!hasSourceId()) {
				memoizedIsInitialized = 0;
				return false;
			}
			if (!hasDestinationId()) {
				memoizedIsInitialized = 0;
				return false;
			}
			if (!hasNamespace()) {
				memoizedIsInitialized = 0;
				return false;
			}
			if (!hasPayloadType()) {
				memoizedIsInitialized = 0;
				return false;
			}
			memoizedIsInitialized = 1;
			return true;
		}

		@Override
		public void writeTo(CodedOutputStream output) throws IOException {
			getSerializedSize();
			if (((bitField0_ & 0x00000001) == 0x00000001)) {
				output.writeEnum(1, protocolVersion_.getNumber());
			}
			if (((bitField0_ & 0x00000002) == 0x00000002)) {
				output.writeBytes(2, getSourceIdBytes());
			}
			if (((bitField0_ & 0x00000004) == 0x00000004)) {
				output.writeBytes(3, getDestinationIdBytes());
			}
			if (((bitField0_ & 0x00000008) == 0x00000008)) {
				output.writeBytes(4, getNamespaceBytes());
			}
			if (((bitField0_ & 0x00000010) == 0x00000010)) {
				output.writeEnum(5, payloadType_.getNumber());
			}
			if (((bitField0_ & 0x00000020) == 0x00000020)) {
				output.writeBytes(6, getPayloadUtf8Bytes());
			}
			if (((bitField0_ & 0x00000040) == 0x00000040)) {
				output.writeBytes(7, payloadBinary_);
			}
			output.writeRawBytes(unknownFields);
		}

		private int memoizedSerializedSize = -1;

		@Override
		public int getSerializedSize() {
			int size = memoizedSerializedSize;
			if (size != -1)
				return size;

			size = 0;
			if (((bitField0_ & 0x00000001) == 0x00000001)) {
				size += CodedOutputStream.computeEnumSize(1, protocolVersion_.getNumber());
			}
			if (((bitField0_ & 0x00000002) == 0x00000002)) {
				size += CodedOutputStream.computeBytesSize(2, getSourceIdBytes());
			}
			if (((bitField0_ & 0x00000004) == 0x00000004)) {
				size += CodedOutputStream.computeBytesSize(3, getDestinationIdBytes());
			}
			if (((bitField0_ & 0x00000008) == 0x00000008)) {
				size += CodedOutputStream.computeBytesSize(4, getNamespaceBytes());
			}
			if (((bitField0_ & 0x00000010) == 0x00000010)) {
				size += CodedOutputStream.computeEnumSize(5, payloadType_.getNumber());
			}
			if (((bitField0_ & 0x00000020) == 0x00000020)) {
				size += CodedOutputStream.computeBytesSize(6, getPayloadUtf8Bytes());
			}
			if (((bitField0_ & 0x00000040) == 0x00000040)) {
				size += CodedOutputStream.computeBytesSize(7, payloadBinary_);
			}
			size += unknownFields.size();
			memoizedSerializedSize = size;
			return size;
		}

		private static final long serialVersionUID = 0L;

		@Override
		protected Object writeReplace() throws ObjectStreamException {
			return super.writeReplace();
		}

		public static CastChannel.CastMessage parseFrom(ByteString data) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static CastChannel.CastMessage parseFrom(
			ByteString data,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static CastChannel.CastMessage parseFrom(byte[] data) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static CastChannel.CastMessage parseFrom(
			byte[] data,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static CastChannel.CastMessage parseFrom(InputStream input) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input);
		}

		public static CastChannel.CastMessage parseFrom(
			InputStream input,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input, extensionRegistry);
		}

		public static CastChannel.CastMessage parseDelimitedFrom(InputStream input) throws InvalidProtocolBufferException {
			return PARSER.parseDelimitedFrom(input);
		}

		public static CastChannel.CastMessage parseDelimitedFrom(
			InputStream input,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseDelimitedFrom(input, extensionRegistry);
		}

		public static CastChannel.CastMessage parseFrom(CodedInputStream input) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input);
		}

		public static CastChannel.CastMessage parseFrom(
			CodedInputStream input,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input, extensionRegistry);
		}

		public static Builder newBuilder() {
			return Builder.create();
		}

		@Override
		public Builder newBuilderForType() {
			return newBuilder();
		}

		public static Builder newBuilder(CastChannel.CastMessage prototype) {
			return newBuilder().mergeFrom(prototype);
		}

		@Override
		public Builder toBuilder() {
			return newBuilder(this);
		}

		/**
		 * Protobuf type
		 * {@code CastMessage}
		 */
		public static final class Builder
			extends GeneratedMessageLite.Builder<CastChannel.CastMessage, Builder>
			implements
			// @@protoc_insertion_point(builder_implements:CastMessage)
			CastChannel.CastMessageOrBuilder {

			// Construct using
			// CastChannel.CastMessage.newBuilder()
			private Builder() {
				maybeForceBuilderInitialization();
			}

			private void maybeForceBuilderInitialization() {
			}

			private static Builder create() {
				return new Builder();
			}

			@Override
			public Builder clear() {
				super.clear();
				protocolVersion_ = CastChannel.CastMessage.ProtocolVersion.CASTV2_1_0;
				bitField0_ = (bitField0_ & ~0x00000001);
				sourceId_ = "";
				bitField0_ = (bitField0_ & ~0x00000002);
				destinationId_ = "";
				bitField0_ = (bitField0_ & ~0x00000004);
				namespace_ = "";
				bitField0_ = (bitField0_ & ~0x00000008);
				payloadType_ = CastChannel.CastMessage.PayloadType.STRING;
				bitField0_ = (bitField0_ & ~0x00000010);
				payloadUtf8_ = "";
				bitField0_ = (bitField0_ & ~0x00000020);
				payloadBinary_ = ByteString.EMPTY;
				bitField0_ = (bitField0_ & ~0x00000040);
				return this;
			}

			@Override
			public Builder clone() {
				return create().mergeFrom(buildPartial());
			}

			@Override
			public CastChannel.CastMessage getDefaultInstanceForType() {
				return CastChannel.CastMessage.getDefaultInstance();
			}

			@Override
			public CastChannel.CastMessage build() {
				CastChannel.CastMessage result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result);
				}
				return result;
			}

			@Override
			public CastChannel.CastMessage buildPartial() {
				CastChannel.CastMessage result = new CastChannel.CastMessage(
					this);
				int from_bitField0_ = bitField0_;
				int to_bitField0_ = 0;
				if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
					to_bitField0_ |= 0x00000001;
				}
				result.protocolVersion_ = protocolVersion_;
				if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
					to_bitField0_ |= 0x00000002;
				}
				result.sourceId_ = sourceId_;
				if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
					to_bitField0_ |= 0x00000004;
				}
				result.destinationId_ = destinationId_;
				if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
					to_bitField0_ |= 0x00000008;
				}
				result.namespace_ = namespace_;
				if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
					to_bitField0_ |= 0x00000010;
				}
				result.payloadType_ = payloadType_;
				if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
					to_bitField0_ |= 0x00000020;
				}
				result.payloadUtf8_ = payloadUtf8_;
				if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
					to_bitField0_ |= 0x00000040;
				}
				result.payloadBinary_ = payloadBinary_;
				result.bitField0_ = to_bitField0_;
				return result;
			}

			@Override
			public Builder mergeFrom(CastChannel.CastMessage other) {
				if (other == CastChannel.CastMessage.getDefaultInstance())
					return this;
				if (other.hasProtocolVersion()) {
					setProtocolVersion(other.getProtocolVersion());
				}
				if (other.hasSourceId()) {
					bitField0_ |= 0x00000002;
					sourceId_ = other.sourceId_;

				}
				if (other.hasDestinationId()) {
					bitField0_ |= 0x00000004;
					destinationId_ = other.destinationId_;

				}
				if (other.hasNamespace()) {
					bitField0_ |= 0x00000008;
					namespace_ = other.namespace_;

				}
				if (other.hasPayloadType()) {
					setPayloadType(other.getPayloadType());
				}
				if (other.hasPayloadUtf8()) {
					bitField0_ |= 0x00000020;
					payloadUtf8_ = other.payloadUtf8_;

				}
				if (other.hasPayloadBinary()) {
					setPayloadBinary(other.getPayloadBinary());
				}
				setUnknownFields(getUnknownFields().concat(other.unknownFields));
				return this;
			}

			@Override
			public boolean isInitialized() {
				if (!hasProtocolVersion()) {

					return false;
				}
				if (!hasSourceId()) {

					return false;
				}
				if (!hasDestinationId()) {

					return false;
				}
				if (!hasNamespace()) {

					return false;
				}
				if (!hasPayloadType()) {

					return false;
				}
				return true;
			}

			@Override
			public Builder mergeFrom(
				CodedInputStream input,
				ExtensionRegistryLite extensionRegistry
			) throws InvalidProtocolBufferException {
				CastChannel.CastMessage parsedMessage = null;
				try {
					parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
				} catch (InvalidProtocolBufferException e) {
					parsedMessage = (CastChannel.CastMessage) e.getUnfinishedMessage();
					throw e;
				} finally {
					if (parsedMessage != null) {
						mergeFrom(parsedMessage);
					}
				}
				return this;
			}

			private int bitField0_;

			private CastChannel.CastMessage.ProtocolVersion protocolVersion_ = CastChannel.CastMessage.ProtocolVersion.CASTV2_1_0;

			/**
			 * <code>required .CastMessage.ProtocolVersion protocol_version = 1;</code>
			 */
			@Override
			public boolean hasProtocolVersion() {
				return ((bitField0_ & 0x00000001) == 0x00000001);
			}

			/**
			 * <code>required .CastMessage.ProtocolVersion protocol_version = 1;</code>
			 */
			@Override
			public CastChannel.CastMessage.ProtocolVersion getProtocolVersion() {
				return protocolVersion_;
			}

			/**
			 * <code>required .CastMessage.ProtocolVersion protocol_version = 1;</code>
			 */
			public Builder setProtocolVersion(CastChannel.CastMessage.ProtocolVersion value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000001;
				protocolVersion_ = value;

				return this;
			}

			/**
			 * <code>required .CastMessage.ProtocolVersion protocol_version = 1;</code>
			 */
			public Builder clearProtocolVersion() {
				bitField0_ = (bitField0_ & ~0x00000001);
				protocolVersion_ = CastChannel.CastMessage.ProtocolVersion.CASTV2_1_0;

				return this;
			}

			private Object sourceId_ = "";

			/**
			 * <code>required string source_id = 2;</code>
			 *
			 * <pre>
			 * source and destination ids identify the origin and destination of the
			 * message.  They are used to route messages between endpoints that share a
			 * device-to-device channel.
			 * For messages between applications:
			 *   - The sender application id is a unique identifier generated on behalf of
			 *     the sender application.
			 *   - The receiver id is always the the session id for the application.
			 * For messages to or from the sender or receiver platform, the special ids
			 * 'sender-0' and 'receiver-0' can be used.
			 * For messages intended for all endpoints using a given channel, the
			 * wildcard destination_id '*' can be used.
			 * </pre>
			 */
			@Override
			public boolean hasSourceId() {
				return ((bitField0_ & 0x00000002) == 0x00000002);
			}

			/**
			 * <code>required string source_id = 2;</code>
			 *
			 * <pre>
			 * source and destination ids identify the origin and destination of the
			 * message.  They are used to route messages between endpoints that share a
			 * device-to-device channel.
			 * For messages between applications:
			 *   - The sender application id is a unique identifier generated on behalf of
			 *     the sender application.
			 *   - The receiver id is always the the session id for the application.
			 * For messages to or from the sender or receiver platform, the special ids
			 * 'sender-0' and 'receiver-0' can be used.
			 * For messages intended for all endpoints using a given channel, the
			 * wildcard destination_id '*' can be used.
			 * </pre>
			 */
			@Override
			public String getSourceId() {
				Object ref = sourceId_;
				if (!(ref instanceof String)) {
					ByteString bs = (ByteString) ref;
					String s = bs.toStringUtf8();
					if (bs.isValidUtf8()) {
						sourceId_ = s;
					}
					return s;
				} else {
					return (String) ref;
				}
			}

			/**
			 * <code>required string source_id = 2;</code>
			 *
			 * <pre>
			 * source and destination ids identify the origin and destination of the
			 * message.  They are used to route messages between endpoints that share a
			 * device-to-device channel.
			 * For messages between applications:
			 *   - The sender application id is a unique identifier generated on behalf of
			 *     the sender application.
			 *   - The receiver id is always the the session id for the application.
			 * For messages to or from the sender or receiver platform, the special ids
			 * 'sender-0' and 'receiver-0' can be used.
			 * For messages intended for all endpoints using a given channel, the
			 * wildcard destination_id '*' can be used.
			 * </pre>
			 */
			@Override
			public ByteString getSourceIdBytes() {
				Object ref = sourceId_;
				if (ref instanceof String) {
					ByteString b = ByteString.copyFromUtf8((String) ref);
					sourceId_ = b;
					return b;
				} else {
					return (ByteString) ref;
				}
			}

			/**
			 * <code>required string source_id = 2;</code>
			 *
			 * <pre>
			 * source and destination ids identify the origin and destination of the
			 * message.  They are used to route messages between endpoints that share a
			 * device-to-device channel.
			 * For messages between applications:
			 *   - The sender application id is a unique identifier generated on behalf of
			 *     the sender application.
			 *   - The receiver id is always the the session id for the application.
			 * For messages to or from the sender or receiver platform, the special ids
			 * 'sender-0' and 'receiver-0' can be used.
			 * For messages intended for all endpoints using a given channel, the
			 * wildcard destination_id '*' can be used.
			 * </pre>
			 */
			public Builder setSourceId(String value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000002;
				sourceId_ = value;

				return this;
			}

			/**
			 * <code>required string source_id = 2;</code>
			 *
			 * <pre>
			 * source and destination ids identify the origin and destination of the
			 * message.  They are used to route messages between endpoints that share a
			 * device-to-device channel.
			 * For messages between applications:
			 *   - The sender application id is a unique identifier generated on behalf of
			 *     the sender application.
			 *   - The receiver id is always the the session id for the application.
			 * For messages to or from the sender or receiver platform, the special ids
			 * 'sender-0' and 'receiver-0' can be used.
			 * For messages intended for all endpoints using a given channel, the
			 * wildcard destination_id '*' can be used.
			 * </pre>
			 */
			public Builder clearSourceId() {
				bitField0_ = (bitField0_ & ~0x00000002);
				sourceId_ = getDefaultInstance().getSourceId();

				return this;
			}

			/**
			 * <code>required string source_id = 2;</code>
			 *
			 * <pre>
			 * source and destination ids identify the origin and destination of the
			 * message.  They are used to route messages between endpoints that share a
			 * device-to-device channel.
			 * For messages between applications:
			 *   - The sender application id is a unique identifier generated on behalf of
			 *     the sender application.
			 *   - The receiver id is always the the session id for the application.
			 * For messages to or from the sender or receiver platform, the special ids
			 * 'sender-0' and 'receiver-0' can be used.
			 * For messages intended for all endpoints using a given channel, the
			 * wildcard destination_id '*' can be used.
			 * </pre>
			 */
			public Builder setSourceIdBytes(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000002;
				sourceId_ = value;

				return this;
			}

			private Object destinationId_ = "";

			/**
			 * <code>required string destination_id = 3;</code>
			 */
			@Override
			public boolean hasDestinationId() {
				return ((bitField0_ & 0x00000004) == 0x00000004);
			}

			/**
			 * <code>required string destination_id = 3;</code>
			 */
			@Override
			public String getDestinationId() {
				Object ref = destinationId_;
				if (!(ref instanceof String)) {
					ByteString bs = (ByteString) ref;
					String s = bs.toStringUtf8();
					if (bs.isValidUtf8()) {
						destinationId_ = s;
					}
					return s;
				} else {
					return (String) ref;
				}
			}

			/**
			 * <code>required string destination_id = 3;</code>
			 */
			@Override
			public ByteString getDestinationIdBytes() {
				Object ref = destinationId_;
				if (ref instanceof String) {
					ByteString b = ByteString.copyFromUtf8((String) ref);
					destinationId_ = b;
					return b;
				} else {
					return (ByteString) ref;
				}
			}

			/**
			 * <code>required string destination_id = 3;</code>
			 */
			public Builder setDestinationId(String value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000004;
				destinationId_ = value;

				return this;
			}

			/**
			 * <code>required string destination_id = 3;</code>
			 */
			public Builder clearDestinationId() {
				bitField0_ = (bitField0_ & ~0x00000004);
				destinationId_ = getDefaultInstance().getDestinationId();

				return this;
			}

			/**
			 * <code>required string destination_id = 3;</code>
			 */
			public Builder setDestinationIdBytes(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000004;
				destinationId_ = value;

				return this;
			}

			private Object namespace_ = "";

			/**
			 * <code>required string namespace = 4;</code>
			 *
			 * <pre>
			 * This is the core multiplexing key.  All messages are sent on a namespace
			 * and endpoints sharing a channel listen on one or more namespaces.  The
			 * namespace defines the protocol and semantics of the message.
			 * </pre>
			 */
			@Override
			public boolean hasNamespace() {
				return ((bitField0_ & 0x00000008) == 0x00000008);
			}

			/**
			 * <code>required string namespace = 4;</code>
			 *
			 * <pre>
			 * This is the core multiplexing key.  All messages are sent on a namespace
			 * and endpoints sharing a channel listen on one or more namespaces.  The
			 * namespace defines the protocol and semantics of the message.
			 * </pre>
			 */
			@Override
			public String getNamespace() {
				Object ref = namespace_;
				if (!(ref instanceof String)) {
					ByteString bs = (ByteString) ref;
					String s = bs.toStringUtf8();
					if (bs.isValidUtf8()) {
						namespace_ = s;
					}
					return s;
				} else {
					return (String) ref;
				}
			}

			/**
			 * <code>required string namespace = 4;</code>
			 *
			 * <pre>
			 * This is the core multiplexing key.  All messages are sent on a namespace
			 * and endpoints sharing a channel listen on one or more namespaces.  The
			 * namespace defines the protocol and semantics of the message.
			 * </pre>
			 */
			@Override
			public ByteString getNamespaceBytes() {
				Object ref = namespace_;
				if (ref instanceof String) {
					ByteString b = ByteString.copyFromUtf8((String) ref);
					namespace_ = b;
					return b;
				} else {
					return (ByteString) ref;
				}
			}

			/**
			 * <code>required string namespace = 4;</code>
			 *
			 * <pre>
			 * This is the core multiplexing key.  All messages are sent on a namespace
			 * and endpoints sharing a channel listen on one or more namespaces.  The
			 * namespace defines the protocol and semantics of the message.
			 * </pre>
			 */
			public Builder setNamespace(String value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000008;
				namespace_ = value;

				return this;
			}

			/**
			 * <code>required string namespace = 4;</code>
			 *
			 * <pre>
			 * This is the core multiplexing key.  All messages are sent on a namespace
			 * and endpoints sharing a channel listen on one or more namespaces.  The
			 * namespace defines the protocol and semantics of the message.
			 * </pre>
			 */
			public Builder clearNamespace() {
				bitField0_ = (bitField0_ & ~0x00000008);
				namespace_ = getDefaultInstance().getNamespace();

				return this;
			}

			/**
			 * <code>required string namespace = 4;</code>
			 *
			 * <pre>
			 * This is the core multiplexing key.  All messages are sent on a namespace
			 * and endpoints sharing a channel listen on one or more namespaces.  The
			 * namespace defines the protocol and semantics of the message.
			 * </pre>
			 */
			public Builder setNamespaceBytes(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000008;
				namespace_ = value;

				return this;
			}

			private CastChannel.CastMessage.PayloadType payloadType_ = CastChannel.CastMessage.PayloadType.STRING;

			/**
			 * <code>required .CastMessage.PayloadType payload_type = 5;</code>
			 */
			@Override
			public boolean hasPayloadType() {
				return ((bitField0_ & 0x00000010) == 0x00000010);
			}

			/**
			 * <code>required .CastMessage.PayloadType payload_type = 5;</code>
			 */
			@Override
			public CastChannel.CastMessage.PayloadType getPayloadType() {
				return payloadType_;
			}

			/**
			 * <code>required .CastMessage.PayloadType payload_type = 5;</code>
			 */
			public Builder setPayloadType(CastChannel.CastMessage.PayloadType value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000010;
				payloadType_ = value;

				return this;
			}

			/**
			 * <code>required .CastMessage.PayloadType payload_type = 5;</code>
			 */
			public Builder clearPayloadType() {
				bitField0_ = (bitField0_ & ~0x00000010);
				payloadType_ = CastChannel.CastMessage.PayloadType.STRING;

				return this;
			}

			private Object payloadUtf8_ = "";

			/**
			 * <code>optional string payload_utf8 = 6;</code>
			 *
			 * <pre>
			 * Depending on payload_type, exactly one of the following optional fields
			 * will always be set.
			 * </pre>
			 */
			@Override
			public boolean hasPayloadUtf8() {
				return ((bitField0_ & 0x00000020) == 0x00000020);
			}

			/**
			 * <code>optional string payload_utf8 = 6;</code>
			 *
			 * <pre>
			 * Depending on payload_type, exactly one of the following optional fields
			 * will always be set.
			 * </pre>
			 */
			@Override
			public String getPayloadUtf8() {
				Object ref = payloadUtf8_;
				if (!(ref instanceof String)) {
					ByteString bs = (ByteString) ref;
					String s = bs.toStringUtf8();
					if (bs.isValidUtf8()) {
						payloadUtf8_ = s;
					}
					return s;
				} else {
					return (String) ref;
				}
			}

			/**
			 * <code>optional string payload_utf8 = 6;</code>
			 *
			 * <pre>
			 * Depending on payload_type, exactly one of the following optional fields
			 * will always be set.
			 * </pre>
			 */
			@Override
			public ByteString getPayloadUtf8Bytes() {
				Object ref = payloadUtf8_;
				if (ref instanceof String) {
					ByteString b = ByteString.copyFromUtf8((String) ref);
					payloadUtf8_ = b;
					return b;
				} else {
					return (ByteString) ref;
				}
			}

			/**
			 * <code>optional string payload_utf8 = 6;</code>
			 *
			 * <pre>
			 * Depending on payload_type, exactly one of the following optional fields
			 * will always be set.
			 * </pre>
			 */
			public Builder setPayloadUtf8(String value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000020;
				payloadUtf8_ = value;

				return this;
			}

			/**
			 * <code>optional string payload_utf8 = 6;</code>
			 *
			 * <pre>
			 * Depending on payload_type, exactly one of the following optional fields
			 * will always be set.
			 * </pre>
			 */
			public Builder clearPayloadUtf8() {
				bitField0_ = (bitField0_ & ~0x00000020);
				payloadUtf8_ = getDefaultInstance().getPayloadUtf8();

				return this;
			}

			/**
			 * <code>optional string payload_utf8 = 6;</code>
			 *
			 * <pre>
			 * Depending on payload_type, exactly one of the following optional fields
			 * will always be set.
			 * </pre>
			 */
			public Builder setPayloadUtf8Bytes(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000020;
				payloadUtf8_ = value;

				return this;
			}

			private ByteString payloadBinary_ = ByteString.EMPTY;

			/**
			 * <code>optional bytes payload_binary = 7;</code>
			 */
			@Override
			public boolean hasPayloadBinary() {
				return ((bitField0_ & 0x00000040) == 0x00000040);
			}

			/**
			 * <code>optional bytes payload_binary = 7;</code>
			 */
			@Override
			public ByteString getPayloadBinary() {
				return payloadBinary_;
			}

			/**
			 * <code>optional bytes payload_binary = 7;</code>
			 */
			public Builder setPayloadBinary(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000040;
				payloadBinary_ = value;

				return this;
			}

			/**
			 * <code>optional bytes payload_binary = 7;</code>
			 */
			public Builder clearPayloadBinary() {
				bitField0_ = (bitField0_ & ~0x00000040);
				payloadBinary_ = getDefaultInstance().getPayloadBinary();

				return this;
			}

			// @@protoc_insertion_point(builder_scope:CastMessage)
		}

		static {
			defaultInstance = new CastMessage(true);
			defaultInstance.initFields();
		}

		// @@protoc_insertion_point(class_scope:CastMessage)
	}

	public interface AuthChallengeOrBuilder extends
		// @@protoc_insertion_point(interface_extends:AuthChallenge)
		MessageLiteOrBuilder {

		/**
		 * <code>optional .SignatureAlgorithm signature_algorithm = 1 [default = RSASSA_PKCS1v15];</code>
		 */
		boolean hasSignatureAlgorithm();

		/**
		 * <code>optional .SignatureAlgorithm signature_algorithm = 1 [default = RSASSA_PKCS1v15];</code>
		 */
		CastChannel.SignatureAlgorithm getSignatureAlgorithm();
	}

	/**
	 * Protobuf type {@code AuthChallenge}
	 *
	 * <pre>
	 * Messages for authentication protocol between a sender and a receiver.
	 * </pre>
	 */
	public static final class AuthChallenge extends GeneratedMessageLite implements
		// @@protoc_insertion_point(message_implements:AuthChallenge)
		AuthChallengeOrBuilder {

		// Use AuthChallenge.newBuilder() to construct.
		private AuthChallenge(GeneratedMessageLite.Builder<?, ?> builder) {
			super(builder);
			this.unknownFields = builder.getUnknownFields();
		}

		private AuthChallenge(boolean noInit) {
			this.unknownFields = ByteString.EMPTY;
		}

		private static final AuthChallenge defaultInstance;

		public static AuthChallenge getDefaultInstance() {
			return defaultInstance;
		}

		@Override
		public AuthChallenge getDefaultInstanceForType() {
			return defaultInstance;
		}

		private final ByteString unknownFields;

		private AuthChallenge(
			CodedInputStream input,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			initFields();
			ByteString.Output unknownFieldsOutput = ByteString.newOutput();
			CodedOutputStream unknownFieldsCodedOutput = CodedOutputStream.newInstance(unknownFieldsOutput);
			try {
				boolean done = false;
				while (!done) {
					int tag = input.readTag();
					switch (tag) {
						case 0:
							done = true;
							break;
						default: {
							if (!parseUnknownField(input, unknownFieldsCodedOutput, extensionRegistry, tag)) {
								done = true;
							}
							break;
						}
						case 8: {
							int rawValue = input.readEnum();
							CastChannel.SignatureAlgorithm value = CastChannel.SignatureAlgorithm
								.valueOf(rawValue);
							if (value == null) {
								unknownFieldsCodedOutput.writeRawVarint32(tag);
								unknownFieldsCodedOutput.writeRawVarint32(rawValue);
							} else {
								bitField0_ |= 0x00000001;
								signatureAlgorithm_ = value;
							}
							break;
						}
					}
				}
			} catch (InvalidProtocolBufferException e) {
				throw e.setUnfinishedMessage(this);
			} catch (IOException e) {
				throw new InvalidProtocolBufferException(e.getMessage()).setUnfinishedMessage(this);
			} finally {
				try {
					unknownFieldsCodedOutput.flush();
				} catch (IOException e) {
					// Should not happen
				} finally {
					unknownFields = unknownFieldsOutput.toByteString();
				}
				makeExtensionsImmutable();
			}
		}

		public static Parser<AuthChallenge> PARSER = new AbstractParser<AuthChallenge>() {

			@Override
			public AuthChallenge parsePartialFrom(
				CodedInputStream input,
				ExtensionRegistryLite extensionRegistry
			) throws InvalidProtocolBufferException {
				return new AuthChallenge(input, extensionRegistry);
			}
		};

		@Override
		public Parser<AuthChallenge> getParserForType() {
			return PARSER;
		}

		private int bitField0_;
		public static final int SIGNATURE_ALGORITHM_FIELD_NUMBER = 1;
		private CastChannel.SignatureAlgorithm signatureAlgorithm_;

		/**
		 * <code>optional .SignatureAlgorithm signature_algorithm = 1 [default = RSASSA_PKCS1v15];</code>
		 */
		@Override
		public boolean hasSignatureAlgorithm() {
			return ((bitField0_ & 0x00000001) == 0x00000001);
		}

		/**
		 * <code>optional .SignatureAlgorithm signature_algorithm = 1 [default = RSASSA_PKCS1v15];</code>
		 */
		@Override
		public CastChannel.SignatureAlgorithm getSignatureAlgorithm() {
			return signatureAlgorithm_;
		}

		private void initFields() {
			signatureAlgorithm_ = CastChannel.SignatureAlgorithm.RSASSA_PKCS1v15;
		}

		private byte memoizedIsInitialized = -1;

		@Override
		public boolean isInitialized() {
			byte isInitialized = memoizedIsInitialized;
			if (isInitialized == 1)
				return true;
			if (isInitialized == 0)
				return false;

			memoizedIsInitialized = 1;
			return true;
		}

		@Override
		public void writeTo(CodedOutputStream output) throws IOException {
			getSerializedSize();
			if (((bitField0_ & 0x00000001) == 0x00000001)) {
				output.writeEnum(1, signatureAlgorithm_.getNumber());
			}
			output.writeRawBytes(unknownFields);
		}

		private int memoizedSerializedSize = -1;

		@Override
		public int getSerializedSize() {
			int size = memoizedSerializedSize;
			if (size != -1)
				return size;

			size = 0;
			if (((bitField0_ & 0x00000001) == 0x00000001)) {
				size += CodedOutputStream.computeEnumSize(1, signatureAlgorithm_.getNumber());
			}
			size += unknownFields.size();
			memoizedSerializedSize = size;
			return size;
		}

		private static final long serialVersionUID = 0L;

		@Override
		protected Object writeReplace() throws ObjectStreamException {
			return super.writeReplace();
		}

		public static AuthChallenge parseFrom(ByteString data) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static AuthChallenge parseFrom(
			ByteString data,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static AuthChallenge parseFrom(byte[] data) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static AuthChallenge parseFrom(
			byte[] data,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static AuthChallenge parseFrom(InputStream input) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input);
		}

		public static AuthChallenge parseFrom(
			InputStream input,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input, extensionRegistry);
		}

		public static AuthChallenge parseDelimitedFrom(InputStream input) throws InvalidProtocolBufferException {
			return PARSER.parseDelimitedFrom(input);
		}

		public static AuthChallenge parseDelimitedFrom(
			InputStream input,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseDelimitedFrom(input, extensionRegistry);
		}

		public static AuthChallenge parseFrom(CodedInputStream input) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input);
		}

		public static AuthChallenge parseFrom(
			CodedInputStream input,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input, extensionRegistry);
		}

		public static Builder newBuilder() {
			return Builder.create();
		}

		@Override
		public Builder newBuilderForType() {
			return newBuilder();
		}

		public static Builder newBuilder(AuthChallenge prototype) {
			return newBuilder().mergeFrom(prototype);
		}

		@Override
		public Builder toBuilder() {
			return newBuilder(this);
		}

		/**
		 * Protobuf type
		 * {@code AuthChallenge}
		 *
		 * <pre>
		 * Messages for authentication protocol between a sender and a receiver.
		 * </pre>
		 */
		public static final class Builder extends
			GeneratedMessageLite.Builder<AuthChallenge, Builder>
			implements
			// @@protoc_insertion_point(builder_implements:AuthChallenge)
			AuthChallengeOrBuilder {

			// Construct using
			// AuthChallenge.newBuilder()
			private Builder() {
				maybeForceBuilderInitialization();
			}

			private void maybeForceBuilderInitialization() {
			}

			private static Builder create() {
				return new Builder();
			}

			@Override
			public Builder clear() {
				super.clear();
				signatureAlgorithm_ = CastChannel.SignatureAlgorithm.RSASSA_PKCS1v15;
				bitField0_ = (bitField0_ & ~0x00000001);
				return this;
			}

			@Override
			public Builder clone() {
				return create().mergeFrom(buildPartial());
			}

			@Override
			public AuthChallenge getDefaultInstanceForType() {
				return AuthChallenge.getDefaultInstance();
			}

			@Override
			public AuthChallenge build() {
				AuthChallenge result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result);
				}
				return result;
			}

			@Override
			public AuthChallenge buildPartial() {
				AuthChallenge result = new AuthChallenge(
					this);
				int from_bitField0_ = bitField0_;
				int to_bitField0_ = 0;
				if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
					to_bitField0_ |= 0x00000001;
				}
				result.signatureAlgorithm_ = signatureAlgorithm_;
				result.bitField0_ = to_bitField0_;
				return result;
			}

			@Override
			public Builder mergeFrom(AuthChallenge other) {
				if (other == AuthChallenge.getDefaultInstance())
					return this;
				if (other.hasSignatureAlgorithm()) {
					setSignatureAlgorithm(other.getSignatureAlgorithm());
				}
				setUnknownFields(getUnknownFields().concat(other.unknownFields));
				return this;
			}

			@Override
			public boolean isInitialized() {
				return true;
			}

			@Override
			public Builder mergeFrom(
				CodedInputStream input,
				ExtensionRegistryLite extensionRegistry
			) throws InvalidProtocolBufferException {
				AuthChallenge parsedMessage = null;
				try {
					parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
				} catch (InvalidProtocolBufferException e) {
					parsedMessage = (AuthChallenge) e.getUnfinishedMessage();
					throw e;
				} finally {
					if (parsedMessage != null) {
						mergeFrom(parsedMessage);
					}
				}
				return this;
			}

			private int bitField0_;

			private CastChannel.SignatureAlgorithm signatureAlgorithm_ = CastChannel.SignatureAlgorithm.RSASSA_PKCS1v15;

			/**
			 * <code>optional .SignatureAlgorithm signature_algorithm = 1 [default = RSASSA_PKCS1v15];</code>
			 */
			@Override
			public boolean hasSignatureAlgorithm() {
				return ((bitField0_ & 0x00000001) == 0x00000001);
			}

			/**
			 * <code>optional .SignatureAlgorithm signature_algorithm = 1 [default = RSASSA_PKCS1v15];</code>
			 */
			@Override
			public CastChannel.SignatureAlgorithm getSignatureAlgorithm() {
				return signatureAlgorithm_;
			}

			/**
			 * <code>optional .SignatureAlgorithm signature_algorithm = 1 [default = RSASSA_PKCS1v15];</code>
			 */
			public Builder setSignatureAlgorithm(CastChannel.SignatureAlgorithm value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000001;
				signatureAlgorithm_ = value;

				return this;
			}

			/**
			 * <code>optional .SignatureAlgorithm signature_algorithm = 1 [default = RSASSA_PKCS1v15];</code>
			 */
			public Builder clearSignatureAlgorithm() {
				bitField0_ = (bitField0_ & ~0x00000001);
				signatureAlgorithm_ = CastChannel.SignatureAlgorithm.RSASSA_PKCS1v15;

				return this;
			}

			// @@protoc_insertion_point(builder_scope:AuthChallenge)
		}

		static {
			defaultInstance = new AuthChallenge(true);
			defaultInstance.initFields();
		}

		// @@protoc_insertion_point(class_scope:AuthChallenge)
	}

	public interface AuthResponseOrBuilder extends
		// @@protoc_insertion_point(interface_extends:AuthResponse)
		MessageLiteOrBuilder {

		/**
		 * <code>required bytes signature = 1;</code>
		 */
		boolean hasSignature();

		/**
		 * <code>required bytes signature = 1;</code>
		 */
		ByteString getSignature();

		/**
		 * <code>required bytes client_auth_certificate = 2;</code>
		 */
		boolean hasClientAuthCertificate();

		/**
		 * <code>required bytes client_auth_certificate = 2;</code>
		 */
		ByteString getClientAuthCertificate();

		/**
		 * <code>repeated bytes intermediate_certificate = 3;</code>
		 */
		List<ByteString> getIntermediateCertificateList();

		/**
		 * <code>repeated bytes intermediate_certificate = 3;</code>
		 */
		int getIntermediateCertificateCount();

		/**
		 * <code>repeated bytes intermediate_certificate = 3;</code>
		 */
		ByteString getIntermediateCertificate(int index);

		/**
		 * <code>optional .SignatureAlgorithm signature_algorithm = 4 [default = RSASSA_PKCS1v15];</code>
		 */
		boolean hasSignatureAlgorithm();

		/**
		 * <code>optional .SignatureAlgorithm signature_algorithm = 4 [default = RSASSA_PKCS1v15];</code>
		 */
		CastChannel.SignatureAlgorithm getSignatureAlgorithm();
	}

	/**
	 * Protobuf type {@code AuthResponse}
	 */
	public static final class AuthResponse extends GeneratedMessageLite implements
		// @@protoc_insertion_point(message_implements:AuthResponse)
		AuthResponseOrBuilder {

		// Use AuthResponse.newBuilder() to construct.
		private AuthResponse(GeneratedMessageLite.Builder<?, ?> builder) {
			super(builder);
			this.unknownFields = builder.getUnknownFields();
		}

		private AuthResponse(boolean noInit) {
			this.unknownFields = ByteString.EMPTY;
		}

		private static final AuthResponse defaultInstance;

		public static AuthResponse getDefaultInstance() {
			return defaultInstance;
		}

		@Override
		public AuthResponse getDefaultInstanceForType() {
			return defaultInstance;
		}

		private final ByteString unknownFields;

		private AuthResponse(
			CodedInputStream input,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			initFields();
			int mutable_bitField0_ = 0;
			ByteString.Output unknownFieldsOutput = ByteString.newOutput();
			CodedOutputStream unknownFieldsCodedOutput = CodedOutputStream
				.newInstance(unknownFieldsOutput);
			try {
				boolean done = false;
				while (!done) {
					int tag = input.readTag();
					switch (tag) {
						case 0:
							done = true;
							break;
						default: {
							if (!parseUnknownField(input, unknownFieldsCodedOutput, extensionRegistry, tag)) {
								done = true;
							}
							break;
						}
						case 10: {
							bitField0_ |= 0x00000001;
							signature_ = input.readBytes();
							break;
						}
						case 18: {
							bitField0_ |= 0x00000002;
							clientAuthCertificate_ = input.readBytes();
							break;
						}
						case 26: {
							if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
								intermediateCertificate_ = new ArrayList<>();
								mutable_bitField0_ |= 0x00000004;
							}
							intermediateCertificate_.add(input.readBytes());
							break;
						}
						case 32: {
							int rawValue = input.readEnum();
							CastChannel.SignatureAlgorithm value = CastChannel.SignatureAlgorithm
								.valueOf(rawValue);
							if (value == null) {
								unknownFieldsCodedOutput.writeRawVarint32(tag);
								unknownFieldsCodedOutput.writeRawVarint32(rawValue);
							} else {
								bitField0_ |= 0x00000004;
								signatureAlgorithm_ = value;
							}
							break;
						}
					}
				}
			} catch (InvalidProtocolBufferException e) {
				throw e.setUnfinishedMessage(this);
			} catch (IOException e) {
				throw new InvalidProtocolBufferException(e.getMessage()).setUnfinishedMessage(this);
			} finally {
				if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
					intermediateCertificate_ = Collections.unmodifiableList(intermediateCertificate_);
				}
				try {
					unknownFieldsCodedOutput.flush();
				} catch (IOException e) {
					// Should not happen
				} finally {
					unknownFields = unknownFieldsOutput.toByteString();
				}
				makeExtensionsImmutable();
			}
		}

		public static Parser<AuthResponse> PARSER = new AbstractParser<AuthResponse>() {

			@Override
			public AuthResponse parsePartialFrom(
				CodedInputStream input,
				ExtensionRegistryLite extensionRegistry
			) throws InvalidProtocolBufferException {
				return new AuthResponse(input, extensionRegistry);
			}
		};

		@Override
		public Parser<AuthResponse> getParserForType() {
			return PARSER;
		}

		private int bitField0_;
		public static final int SIGNATURE_FIELD_NUMBER = 1;
		private ByteString signature_;

		/**
		 * <code>required bytes signature = 1;</code>
		 */
		@Override
		public boolean hasSignature() {
			return ((bitField0_ & 0x00000001) == 0x00000001);
		}

		/**
		 * <code>required bytes signature = 1;</code>
		 */
		@Override
		public ByteString getSignature() {
			return signature_;
		}

		public static final int CLIENT_AUTH_CERTIFICATE_FIELD_NUMBER = 2;
		private ByteString clientAuthCertificate_;

		/**
		 * <code>required bytes client_auth_certificate = 2;</code>
		 */
		@Override
		public boolean hasClientAuthCertificate() {
			return ((bitField0_ & 0x00000002) == 0x00000002);
		}

		/**
		 * <code>required bytes client_auth_certificate = 2;</code>
		 */
		@Override
		public ByteString getClientAuthCertificate() {
			return clientAuthCertificate_;
		}

		public static final int INTERMEDIATE_CERTIFICATE_FIELD_NUMBER = 3;
		private List<ByteString> intermediateCertificate_;

		/**
		 * <code>repeated bytes intermediate_certificate = 3;</code>
		 */
		@Override
		public List<ByteString> getIntermediateCertificateList() {
			return intermediateCertificate_;
		}

		/**
		 * <code>repeated bytes intermediate_certificate = 3;</code>
		 */
		@Override
		public int getIntermediateCertificateCount() {
			return intermediateCertificate_.size();
		}

		/**
		 * <code>repeated bytes intermediate_certificate = 3;</code>
		 */
		@Override
		public ByteString getIntermediateCertificate(int index) {
			return intermediateCertificate_.get(index);
		}

		public static final int SIGNATURE_ALGORITHM_FIELD_NUMBER = 4;
		private CastChannel.SignatureAlgorithm signatureAlgorithm_;

		/**
		 * <code>optional .SignatureAlgorithm signature_algorithm = 4 [default = RSASSA_PKCS1v15];</code>
		 */
		@Override
		public boolean hasSignatureAlgorithm() {
			return ((bitField0_ & 0x00000004) == 0x00000004);
		}

		/**
		 * <code>optional .SignatureAlgorithm signature_algorithm = 4 [default = RSASSA_PKCS1v15];</code>
		 */
		@Override
		public CastChannel.SignatureAlgorithm getSignatureAlgorithm() {
			return signatureAlgorithm_;
		}

		private void initFields() {
			signature_ = ByteString.EMPTY;
			clientAuthCertificate_ = ByteString.EMPTY;
			intermediateCertificate_ = Collections.emptyList();
			signatureAlgorithm_ = CastChannel.SignatureAlgorithm.RSASSA_PKCS1v15;
		}

		private byte memoizedIsInitialized = -1;

		@Override
		public boolean isInitialized() {
			byte isInitialized = memoizedIsInitialized;
			if (isInitialized == 1)
				return true;
			if (isInitialized == 0)
				return false;

			if (!hasSignature()) {
				memoizedIsInitialized = 0;
				return false;
			}
			if (!hasClientAuthCertificate()) {
				memoizedIsInitialized = 0;
				return false;
			}
			memoizedIsInitialized = 1;
			return true;
		}

		@Override
		public void writeTo(CodedOutputStream output) throws IOException {
			getSerializedSize();
			if (((bitField0_ & 0x00000001) == 0x00000001)) {
				output.writeBytes(1, signature_);
			}
			if (((bitField0_ & 0x00000002) == 0x00000002)) {
				output.writeBytes(2, clientAuthCertificate_);
			}
			for (int i = 0; i < intermediateCertificate_.size(); i++) {
				output.writeBytes(3, intermediateCertificate_.get(i));
			}
			if (((bitField0_ & 0x00000004) == 0x00000004)) {
				output.writeEnum(4, signatureAlgorithm_.getNumber());
			}
			output.writeRawBytes(unknownFields);
		}

		private int memoizedSerializedSize = -1;

		@Override
		public int getSerializedSize() {
			int size = memoizedSerializedSize;
			if (size != -1)
				return size;

			size = 0;
			if (((bitField0_ & 0x00000001) == 0x00000001)) {
				size += CodedOutputStream.computeBytesSize(1, signature_);
			}
			if (((bitField0_ & 0x00000002) == 0x00000002)) {
				size += CodedOutputStream.computeBytesSize(2, clientAuthCertificate_);
			}
			{
				int dataSize = 0;
				for (int i = 0; i < intermediateCertificate_.size(); i++) {
					dataSize += CodedOutputStream.computeBytesSizeNoTag(intermediateCertificate_.get(i));
				}
				size += dataSize;
				size += 1 * getIntermediateCertificateList().size();
			}
			if (((bitField0_ & 0x00000004) == 0x00000004)) {
				size += CodedOutputStream.computeEnumSize(4, signatureAlgorithm_.getNumber());
			}
			size += unknownFields.size();
			memoizedSerializedSize = size;
			return size;
		}

		private static final long serialVersionUID = 0L;

		@Override
		protected Object writeReplace() throws ObjectStreamException {
			return super.writeReplace();
		}

		public static CastChannel.AuthResponse parseFrom(ByteString data) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static CastChannel.AuthResponse parseFrom(
			ByteString data,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static CastChannel.AuthResponse parseFrom(byte[] data) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static CastChannel.AuthResponse parseFrom(
			byte[] data,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static CastChannel.AuthResponse parseFrom(InputStream input) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input);
		}

		public static CastChannel.AuthResponse parseFrom(
			InputStream input,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input, extensionRegistry);
		}

		public static CastChannel.AuthResponse parseDelimitedFrom(InputStream input) throws InvalidProtocolBufferException {
			return PARSER.parseDelimitedFrom(input);
		}

		public static CastChannel.AuthResponse parseDelimitedFrom(
			InputStream input,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseDelimitedFrom(input, extensionRegistry);
		}

		public static CastChannel.AuthResponse parseFrom(CodedInputStream input) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input);
		}

		public static CastChannel.AuthResponse parseFrom(
			CodedInputStream input,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input, extensionRegistry);
		}

		public static Builder newBuilder() {
			return Builder.create();
		}

		@Override
		public Builder newBuilderForType() {
			return newBuilder();
		}

		public static Builder newBuilder(CastChannel.AuthResponse prototype) {
			return newBuilder().mergeFrom(prototype);
		}

		@Override
		public Builder toBuilder() {
			return newBuilder(this);
		}

		/**
		 * Protobuf type
		 * {@code AuthResponse}
		 */
		public static final class Builder extends
			GeneratedMessageLite.Builder<CastChannel.AuthResponse, Builder>
			implements
			// @@protoc_insertion_point(builder_implements:AuthResponse)
			CastChannel.AuthResponseOrBuilder {

			// Construct using
			// CastChannel.AuthResponse.newBuilder()
			private Builder() {
				maybeForceBuilderInitialization();
			}

			private void maybeForceBuilderInitialization() {
			}

			private static Builder create() {
				return new Builder();
			}

			@Override
			public Builder clear() {
				super.clear();
				signature_ = ByteString.EMPTY;
				bitField0_ = (bitField0_ & ~0x00000001);
				clientAuthCertificate_ = ByteString.EMPTY;
				bitField0_ = (bitField0_ & ~0x00000002);
				intermediateCertificate_ = Collections.emptyList();
				bitField0_ = (bitField0_ & ~0x00000004);
				signatureAlgorithm_ = CastChannel.SignatureAlgorithm.RSASSA_PKCS1v15;
				bitField0_ = (bitField0_ & ~0x00000008);
				return this;
			}

			@Override
			public Builder clone() {
				return create().mergeFrom(buildPartial());
			}

			@Override
			public CastChannel.AuthResponse getDefaultInstanceForType() {
				return CastChannel.AuthResponse.getDefaultInstance();
			}

			@Override
			public CastChannel.AuthResponse build() {
				CastChannel.AuthResponse result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result);
				}
				return result;
			}

			@Override
			public CastChannel.AuthResponse buildPartial() {
				CastChannel.AuthResponse result = new CastChannel.AuthResponse(
					this);
				int from_bitField0_ = bitField0_;
				int to_bitField0_ = 0;
				if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
					to_bitField0_ |= 0x00000001;
				}
				result.signature_ = signature_;
				if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
					to_bitField0_ |= 0x00000002;
				}
				result.clientAuthCertificate_ = clientAuthCertificate_;
				if (((bitField0_ & 0x00000004) == 0x00000004)) {
					intermediateCertificate_ = Collections.unmodifiableList(intermediateCertificate_);
					bitField0_ = (bitField0_ & ~0x00000004);
				}
				result.intermediateCertificate_ = intermediateCertificate_;
				if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
					to_bitField0_ |= 0x00000004;
				}
				result.signatureAlgorithm_ = signatureAlgorithm_;
				result.bitField0_ = to_bitField0_;
				return result;
			}

			@Override
			public Builder mergeFrom(CastChannel.AuthResponse other) {
				if (other == CastChannel.AuthResponse.getDefaultInstance())
					return this;
				if (other.hasSignature()) {
					setSignature(other.getSignature());
				}
				if (other.hasClientAuthCertificate()) {
					setClientAuthCertificate(other.getClientAuthCertificate());
				}
				if (!other.intermediateCertificate_.isEmpty()) {
					if (intermediateCertificate_.isEmpty()) {
						intermediateCertificate_ = other.intermediateCertificate_;
						bitField0_ = (bitField0_ & ~0x00000004);
					} else {
						ensureIntermediateCertificateIsMutable();
						intermediateCertificate_.addAll(other.intermediateCertificate_);
					}

				}
				if (other.hasSignatureAlgorithm()) {
					setSignatureAlgorithm(other.getSignatureAlgorithm());
				}
				setUnknownFields(getUnknownFields().concat(other.unknownFields));
				return this;
			}

			@Override
			public boolean isInitialized() {
				if (!hasSignature()) {

					return false;
				}
				if (!hasClientAuthCertificate()) {

					return false;
				}
				return true;
			}

			@Override
			public Builder mergeFrom(
				CodedInputStream input,
				ExtensionRegistryLite extensionRegistry
			) throws InvalidProtocolBufferException {
				CastChannel.AuthResponse parsedMessage = null;
				try {
					parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
				} catch (InvalidProtocolBufferException e) {
					parsedMessage = (CastChannel.AuthResponse) e.getUnfinishedMessage();
					throw e;
				} finally {
					if (parsedMessage != null) {
						mergeFrom(parsedMessage);
					}
				}
				return this;
			}

			private int bitField0_;

			private ByteString signature_ = ByteString.EMPTY;

			/**
			 * <code>required bytes signature = 1;</code>
			 */
			@Override
			public boolean hasSignature() {
				return ((bitField0_ & 0x00000001) == 0x00000001);
			}

			/**
			 * <code>required bytes signature = 1;</code>
			 */
			@Override
			public ByteString getSignature() {
				return signature_;
			}

			/**
			 * <code>required bytes signature = 1;</code>
			 */
			public Builder setSignature(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000001;
				signature_ = value;

				return this;
			}

			/**
			 * <code>required bytes signature = 1;</code>
			 */
			public Builder clearSignature() {
				bitField0_ = (bitField0_ & ~0x00000001);
				signature_ = getDefaultInstance().getSignature();

				return this;
			}

			private ByteString clientAuthCertificate_ = ByteString.EMPTY;

			/**
			 * <code>required bytes client_auth_certificate = 2;</code>
			 */
			@Override
			public boolean hasClientAuthCertificate() {
				return ((bitField0_ & 0x00000002) == 0x00000002);
			}

			/**
			 * <code>required bytes client_auth_certificate = 2;</code>
			 */
			@Override
			public ByteString getClientAuthCertificate() {
				return clientAuthCertificate_;
			}

			/**
			 * <code>required bytes client_auth_certificate = 2;</code>
			 */
			public Builder setClientAuthCertificate(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000002;
				clientAuthCertificate_ = value;

				return this;
			}

			/**
			 * <code>required bytes client_auth_certificate = 2;</code>
			 */
			public Builder clearClientAuthCertificate() {
				bitField0_ = (bitField0_ & ~0x00000002);
				clientAuthCertificate_ = getDefaultInstance().getClientAuthCertificate();

				return this;
			}

			private List<ByteString> intermediateCertificate_ = Collections.emptyList();

			private void ensureIntermediateCertificateIsMutable() {
				if (!((bitField0_ & 0x00000004) == 0x00000004)) {
					intermediateCertificate_ = new ArrayList<>(intermediateCertificate_);
					bitField0_ |= 0x00000004;
				}
			}

			/**
			 * <code>repeated bytes intermediate_certificate = 3;</code>
			 */
			@Override
			public List<ByteString> getIntermediateCertificateList() {
				return Collections.unmodifiableList(intermediateCertificate_);
			}

			/**
			 * <code>repeated bytes intermediate_certificate = 3;</code>
			 */
			@Override
			public int getIntermediateCertificateCount() {
				return intermediateCertificate_.size();
			}

			/**
			 * <code>repeated bytes intermediate_certificate = 3;</code>
			 */
			@Override
			public ByteString getIntermediateCertificate(int index) {
				return intermediateCertificate_.get(index);
			}

			/**
			 * <code>repeated bytes intermediate_certificate = 3;</code>
			 */
			public Builder setIntermediateCertificate(int index, ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				ensureIntermediateCertificateIsMutable();
				intermediateCertificate_.set(index, value);

				return this;
			}

			/**
			 * <code>repeated bytes intermediate_certificate = 3;</code>
			 */
			public Builder addIntermediateCertificate(ByteString value) {
				if (value == null) {
					throw new NullPointerException();
				}
				ensureIntermediateCertificateIsMutable();
				intermediateCertificate_.add(value);

				return this;
			}

			/**
			 * <code>repeated bytes intermediate_certificate = 3;</code>
			 */
			public Builder addAllIntermediateCertificate(Iterable<? extends ByteString> values) {
				ensureIntermediateCertificateIsMutable();
				AbstractMessageLite.Builder.addAll(values, intermediateCertificate_);

				return this;
			}

			/**
			 * <code>repeated bytes intermediate_certificate = 3;</code>
			 */
			public Builder clearIntermediateCertificate() {
				intermediateCertificate_ = Collections.emptyList();
				bitField0_ = (bitField0_ & ~0x00000004);

				return this;
			}

			private CastChannel.SignatureAlgorithm signatureAlgorithm_ = CastChannel.SignatureAlgorithm.RSASSA_PKCS1v15;

			/**
			 * <code>optional .SignatureAlgorithm signature_algorithm = 4 [default = RSASSA_PKCS1v15];</code>
			 */
			@Override
			public boolean hasSignatureAlgorithm() {
				return ((bitField0_ & 0x00000008) == 0x00000008);
			}

			/**
			 * <code>optional .SignatureAlgorithm signature_algorithm = 4 [default = RSASSA_PKCS1v15];</code>
			 */
			@Override
			public CastChannel.SignatureAlgorithm getSignatureAlgorithm() {
				return signatureAlgorithm_;
			}

			/**
			 * <code>optional .SignatureAlgorithm signature_algorithm = 4 [default = RSASSA_PKCS1v15];</code>
			 */
			public Builder setSignatureAlgorithm(CastChannel.SignatureAlgorithm value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000008;
				signatureAlgorithm_ = value;

				return this;
			}

			/**
			 * <code>optional .SignatureAlgorithm signature_algorithm = 4 [default = RSASSA_PKCS1v15];</code>
			 */
			public Builder clearSignatureAlgorithm() {
				bitField0_ = (bitField0_ & ~0x00000008);
				signatureAlgorithm_ = CastChannel.SignatureAlgorithm.RSASSA_PKCS1v15;

				return this;
			}

			// @@protoc_insertion_point(builder_scope:AuthResponse)
		}

		static {
			defaultInstance = new AuthResponse(true);
			defaultInstance.initFields();
		}

		// @@protoc_insertion_point(class_scope:AuthResponse)
	}

	public interface AuthErrorOrBuilder extends
		// @@protoc_insertion_point(interface_extends:AuthError)
		MessageLiteOrBuilder {

		/**
		 * <code>required .AuthError.ErrorType error_type = 1;</code>
		 */
		boolean hasErrorType();

		/**
		 * <code>required .AuthError.ErrorType error_type = 1;</code>
		 */
		CastChannel.AuthError.ErrorType getErrorType();
	}

	/**
	 * Protobuf type {@code AuthError}
	 */
	public static final class AuthError extends GeneratedMessageLite implements
		// @@protoc_insertion_point(message_implements:AuthError)
		AuthErrorOrBuilder {

		// Use AuthError.newBuilder() to construct.
		private AuthError(GeneratedMessageLite.Builder<?, ?> builder) {
			super(builder);
			this.unknownFields = builder.getUnknownFields();
		}

		private AuthError(boolean noInit) {
			this.unknownFields = ByteString.EMPTY;
		}

		private static final AuthError defaultInstance;

		public static AuthError getDefaultInstance() {
			return defaultInstance;
		}

		@Override
		public AuthError getDefaultInstanceForType() {
			return defaultInstance;
		}

		private final ByteString unknownFields;

		private AuthError(
			CodedInputStream input,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			initFields();
			ByteString.Output unknownFieldsOutput = ByteString.newOutput();
			CodedOutputStream unknownFieldsCodedOutput = CodedOutputStream.newInstance(unknownFieldsOutput);
			try {
				boolean done = false;
				while (!done) {
					int tag = input.readTag();
					switch (tag) {
						case 0:
							done = true;
							break;
						default: {
							if (!parseUnknownField(input, unknownFieldsCodedOutput, extensionRegistry, tag)) {
								done = true;
							}
							break;
						}
						case 8: {
							int rawValue = input.readEnum();
							CastChannel.AuthError.ErrorType value = CastChannel.AuthError.ErrorType
								.valueOf(rawValue);
							if (value == null) {
								unknownFieldsCodedOutput.writeRawVarint32(tag);
								unknownFieldsCodedOutput.writeRawVarint32(rawValue);
							} else {
								bitField0_ |= 0x00000001;
								errorType_ = value;
							}
							break;
						}
					}
				}
			} catch (InvalidProtocolBufferException e) {
				throw e.setUnfinishedMessage(this);
			} catch (IOException e) {
				throw new InvalidProtocolBufferException(e.getMessage()).setUnfinishedMessage(this);
			} finally {
				try {
					unknownFieldsCodedOutput.flush();
				} catch (IOException e) {
					// Should not happen
				} finally {
					unknownFields = unknownFieldsOutput.toByteString();
				}
				makeExtensionsImmutable();
			}
		}

		public static Parser<AuthError> PARSER = new AbstractParser<AuthError>() {

			@Override
			public AuthError parsePartialFrom(
				CodedInputStream input,
				ExtensionRegistryLite extensionRegistry
			) throws InvalidProtocolBufferException {
				return new AuthError(input, extensionRegistry);
			}
		};

		@Override
		public Parser<AuthError> getParserForType() {
			return PARSER;
		}

		/**
		 * Protobuf enum
		 * {@code AuthError.ErrorType}
		 */
		public enum ErrorType implements Internal.EnumLite {

			/**
			 * <code>INTERNAL_ERROR = 0;</code>
			 */
			INTERNAL_ERROR(0, 0),
			/**
			 * <code>NO_TLS = 1;</code>
			 *
			 * <pre>
			 * The underlying connection is not TLS
			 * </pre>
			 */
			NO_TLS(1, 1),
			/**
			 * <code>SIGNATURE_ALGORITHM_UNAVAILABLE = 2;</code>
			 */
			SIGNATURE_ALGORITHM_UNAVAILABLE(2, 2),;

			/**
			 * <code>INTERNAL_ERROR = 0;</code>
			 */
			public static final int INTERNAL_ERROR_VALUE = 0;
			/**
			 * <code>NO_TLS = 1;</code>
			 *
			 * <pre>
			 * The underlying connection is not TLS
			 * </pre>
			 */
			public static final int NO_TLS_VALUE = 1;
			/**
			 * <code>SIGNATURE_ALGORITHM_UNAVAILABLE = 2;</code>
			 */
			public static final int SIGNATURE_ALGORITHM_UNAVAILABLE_VALUE = 2;

			@Override
			public final int getNumber() {
				return value;
			}

			public static ErrorType valueOf(int value) {
				switch (value) {
					case 0:
						return INTERNAL_ERROR;
					case 1:
						return NO_TLS;
					case 2:
						return SIGNATURE_ALGORITHM_UNAVAILABLE;
					default:
						return null;
				}
			}

			public static Internal.EnumLiteMap<ErrorType> internalGetValueMap() {
				return internalValueMap;
			}

			private static Internal.EnumLiteMap<ErrorType> internalValueMap = new Internal.EnumLiteMap<ErrorType>() {

				@Override
				public ErrorType findValueByNumber(int number) {
					return ErrorType.valueOf(number);
				}
			};

			private final int value;

			private ErrorType(int index, int value) {
				this.value = value;
			}

			// @@protoc_insertion_point(enum_scope:AuthError.ErrorType)
		}

		private int bitField0_;
		public static final int ERROR_TYPE_FIELD_NUMBER = 1;
		private CastChannel.AuthError.ErrorType errorType_;

		/**
		 * <code>required .AuthError.ErrorType error_type = 1;</code>
		 */
		@Override
		public boolean hasErrorType() {
			return ((bitField0_ & 0x00000001) == 0x00000001);
		}

		/**
		 * <code>required .AuthError.ErrorType error_type = 1;</code>
		 */
		@Override
		public CastChannel.AuthError.ErrorType getErrorType() {
			return errorType_;
		}

		private void initFields() {
			errorType_ = CastChannel.AuthError.ErrorType.INTERNAL_ERROR;
		}

		private byte memoizedIsInitialized = -1;

		@Override
		public boolean isInitialized() {
			byte isInitialized = memoizedIsInitialized;
			if (isInitialized == 1)
				return true;
			if (isInitialized == 0)
				return false;

			if (!hasErrorType()) {
				memoizedIsInitialized = 0;
				return false;
			}
			memoizedIsInitialized = 1;
			return true;
		}

		@Override
		public void writeTo(CodedOutputStream output) throws IOException {
			getSerializedSize();
			if (((bitField0_ & 0x00000001) == 0x00000001)) {
				output.writeEnum(1, errorType_.getNumber());
			}
			output.writeRawBytes(unknownFields);
		}

		private int memoizedSerializedSize = -1;

		@Override
		public int getSerializedSize() {
			int size = memoizedSerializedSize;
			if (size != -1)
				return size;

			size = 0;
			if (((bitField0_ & 0x00000001) == 0x00000001)) {
				size += CodedOutputStream.computeEnumSize(1, errorType_.getNumber());
			}
			size += unknownFields.size();
			memoizedSerializedSize = size;
			return size;
		}

		private static final long serialVersionUID = 0L;

		@Override
		protected Object writeReplace() throws ObjectStreamException {
			return super.writeReplace();
		}

		public static CastChannel.AuthError parseFrom(ByteString data) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static CastChannel.AuthError parseFrom(
			ByteString data,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static CastChannel.AuthError parseFrom(byte[] data) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static CastChannel.AuthError parseFrom(
			byte[] data,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static CastChannel.AuthError parseFrom(InputStream input) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input);
		}

		public static CastChannel.AuthError parseFrom(
			InputStream input,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input, extensionRegistry);
		}

		public static CastChannel.AuthError parseDelimitedFrom(InputStream input) throws InvalidProtocolBufferException {
			return PARSER.parseDelimitedFrom(input);
		}

		public static CastChannel.AuthError parseDelimitedFrom(
			InputStream input,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseDelimitedFrom(input, extensionRegistry);
		}

		public static CastChannel.AuthError parseFrom(CodedInputStream input) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input);
		}

		public static CastChannel.AuthError parseFrom(
			CodedInputStream input,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input, extensionRegistry);
		}

		public static Builder newBuilder() {
			return Builder.create();
		}

		@Override
		public Builder newBuilderForType() {
			return newBuilder();
		}

		public static Builder newBuilder(CastChannel.AuthError prototype) {
			return newBuilder().mergeFrom(prototype);
		}

		@Override
		public Builder toBuilder() {
			return newBuilder(this);
		}

		/**
		 * Protobuf type {@code AuthError}
		 */
		public static final class Builder
			extends GeneratedMessageLite.Builder<CastChannel.AuthError, Builder>
			implements
			// @@protoc_insertion_point(builder_implements:AuthError)
			CastChannel.AuthErrorOrBuilder {

			// Construct using
			// CastChannel.AuthError.newBuilder()
			private Builder() {
				maybeForceBuilderInitialization();
			}

			private void maybeForceBuilderInitialization() {
			}

			private static Builder create() {
				return new Builder();
			}

			@Override
			public Builder clear() {
				super.clear();
				errorType_ = CastChannel.AuthError.ErrorType.INTERNAL_ERROR;
				bitField0_ = (bitField0_ & ~0x00000001);
				return this;
			}

			@Override
			public Builder clone() {
				return create().mergeFrom(buildPartial());
			}

			@Override
			public CastChannel.AuthError getDefaultInstanceForType() {
				return CastChannel.AuthError.getDefaultInstance();
			}

			@Override
			public CastChannel.AuthError build() {
				CastChannel.AuthError result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result);
				}
				return result;
			}

			@Override
			public CastChannel.AuthError buildPartial() {
				CastChannel.AuthError result = new CastChannel.AuthError(
					this);
				int from_bitField0_ = bitField0_;
				int to_bitField0_ = 0;
				if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
					to_bitField0_ |= 0x00000001;
				}
				result.errorType_ = errorType_;
				result.bitField0_ = to_bitField0_;
				return result;
			}

			@Override
			public Builder mergeFrom(CastChannel.AuthError other) {
				if (other == CastChannel.AuthError.getDefaultInstance())
					return this;
				if (other.hasErrorType()) {
					setErrorType(other.getErrorType());
				}
				setUnknownFields(getUnknownFields().concat(other.unknownFields));
				return this;
			}

			@Override
			public boolean isInitialized() {
				if (!hasErrorType()) {

					return false;
				}
				return true;
			}

			@Override
			public Builder mergeFrom(
				CodedInputStream input,
				ExtensionRegistryLite extensionRegistry
			) throws InvalidProtocolBufferException {
				CastChannel.AuthError parsedMessage = null;
				try {
					parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
				} catch (InvalidProtocolBufferException e) {
					parsedMessage = (CastChannel.AuthError) e.getUnfinishedMessage();
					throw e;
				} finally {
					if (parsedMessage != null) {
						mergeFrom(parsedMessage);
					}
				}
				return this;
			}

			private int bitField0_;

			private CastChannel.AuthError.ErrorType errorType_ = CastChannel.AuthError.ErrorType.INTERNAL_ERROR;

			/**
			 * <code>required .AuthError.ErrorType error_type = 1;</code>
			 */
			@Override
			public boolean hasErrorType() {
				return ((bitField0_ & 0x00000001) == 0x00000001);
			}

			/**
			 * <code>required .AuthError.ErrorType error_type = 1;</code>
			 */
			@Override
			public CastChannel.AuthError.ErrorType getErrorType() {
				return errorType_;
			}

			/**
			 * <code>required .AuthError.ErrorType error_type = 1;</code>
			 */
			public Builder setErrorType(CastChannel.AuthError.ErrorType value) {
				if (value == null) {
					throw new NullPointerException();
				}
				bitField0_ |= 0x00000001;
				errorType_ = value;

				return this;
			}

			/**
			 * <code>required .AuthError.ErrorType error_type = 1;</code>
			 */
			public Builder clearErrorType() {
				bitField0_ = (bitField0_ & ~0x00000001);
				errorType_ = CastChannel.AuthError.ErrorType.INTERNAL_ERROR;

				return this;
			}

			// @@protoc_insertion_point(builder_scope:AuthError)
		}

		static {
			defaultInstance = new AuthError(true);
			defaultInstance.initFields();
		}

		// @@protoc_insertion_point(class_scope:AuthError)
	}

	public interface DeviceAuthMessageOrBuilder extends
		// @@protoc_insertion_point(interface_extends:DeviceAuthMessage)
		MessageLiteOrBuilder {

		/**
		 * <code>optional .AuthChallenge challenge = 1;</code>
		 *
		 * <pre>
		 * Request fields
		 * </pre>
		 */
		boolean hasChallenge();

		/**
		 * <code>optional .AuthChallenge challenge = 1;</code>
		 *
		 * <pre>
		 * Request fields
		 * </pre>
		 */
		AuthChallenge getChallenge();

		/**
		 * <code>optional .AuthResponse response = 2;</code>
		 *
		 * <pre>
		 * Response fields
		 * </pre>
		 */
		boolean hasResponse();

		/**
		 * <code>optional .AuthResponse response = 2;</code>
		 *
		 * <pre>
		 * Response fields
		 * </pre>
		 */
		CastChannel.AuthResponse getResponse();

		/**
		 * <code>optional .AuthError error = 3;</code>
		 */
		boolean hasError();

		/**
		 * <code>optional .AuthError error = 3;</code>
		 */
		CastChannel.AuthError getError();
	}

	/**
	 * Protobuf type
	 * {@code DeviceAuthMessage}
	 */
	public static final class DeviceAuthMessage extends GeneratedMessageLite implements
		// @@protoc_insertion_point(message_implements:DeviceAuthMessage)
		DeviceAuthMessageOrBuilder {

		// Use DeviceAuthMessage.newBuilder() to construct.
		private DeviceAuthMessage(GeneratedMessageLite.Builder<?, ?> builder) {
			super(builder);
			this.unknownFields = builder.getUnknownFields();
		}

		private DeviceAuthMessage(boolean noInit) {
			this.unknownFields = ByteString.EMPTY;
		}

		private static final DeviceAuthMessage defaultInstance;

		public static DeviceAuthMessage getDefaultInstance() {
			return defaultInstance;
		}

		@Override
		public DeviceAuthMessage getDefaultInstanceForType() {
			return defaultInstance;
		}

		private final ByteString unknownFields;

		private DeviceAuthMessage(
			CodedInputStream input,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			initFields();
			ByteString.Output unknownFieldsOutput = ByteString.newOutput();
			CodedOutputStream unknownFieldsCodedOutput = CodedOutputStream.newInstance(unknownFieldsOutput);
			try {
				boolean done = false;
				while (!done) {
					int tag = input.readTag();
					switch (tag) {
						case 0:
							done = true;
							break;
						default: {
							if (!parseUnknownField(input, unknownFieldsCodedOutput, extensionRegistry, tag)) {
								done = true;
							}
							break;
						}
						case 10: {
							AuthChallenge.Builder subBuilder = null;
							if (((bitField0_ & 0x00000001) == 0x00000001)) {
								subBuilder = challenge_.toBuilder();
							}
							challenge_ = input.readMessage(AuthChallenge.PARSER,
								extensionRegistry);
							if (subBuilder != null) {
								subBuilder.mergeFrom(challenge_);
								challenge_ = subBuilder.buildPartial();
							}
							bitField0_ |= 0x00000001;
							break;
						}
						case 18: {
							CastChannel.AuthResponse.Builder subBuilder = null;
							if (((bitField0_ & 0x00000002) == 0x00000002)) {
								subBuilder = response_.toBuilder();
							}
							response_ = input.readMessage(CastChannel.AuthResponse.PARSER,
								extensionRegistry);
							if (subBuilder != null) {
								subBuilder.mergeFrom(response_);
								response_ = subBuilder.buildPartial();
							}
							bitField0_ |= 0x00000002;
							break;
						}
						case 26: {
							CastChannel.AuthError.Builder subBuilder = null;
							if (((bitField0_ & 0x00000004) == 0x00000004)) {
								subBuilder = error_.toBuilder();
							}
							error_ = input.readMessage(CastChannel.AuthError.PARSER,
								extensionRegistry);
							if (subBuilder != null) {
								subBuilder.mergeFrom(error_);
								error_ = subBuilder.buildPartial();
							}
							bitField0_ |= 0x00000004;
							break;
						}
					}
				}
			} catch (InvalidProtocolBufferException e) {
				throw e.setUnfinishedMessage(this);
			} catch (IOException e) {
				throw new InvalidProtocolBufferException(e.getMessage()).setUnfinishedMessage(this);
			} finally {
				try {
					unknownFieldsCodedOutput.flush();
				} catch (IOException e) {
					// Should not happen
				} finally {
					unknownFields = unknownFieldsOutput.toByteString();
				}
				makeExtensionsImmutable();
			}
		}

		public static Parser<DeviceAuthMessage> PARSER = new AbstractParser<DeviceAuthMessage>() {

			@Override
			public DeviceAuthMessage parsePartialFrom(
				CodedInputStream input,
				ExtensionRegistryLite extensionRegistry
			) throws InvalidProtocolBufferException {
				return new DeviceAuthMessage(input, extensionRegistry);
			}
		};

		@Override
		public Parser<DeviceAuthMessage> getParserForType() {
			return PARSER;
		}

		private int bitField0_;
		public static final int CHALLENGE_FIELD_NUMBER = 1;
		private AuthChallenge challenge_;

		/**
		 * <code>optional .AuthChallenge challenge = 1;</code>
		 *
		 * <pre>
		 * Request fields
		 * </pre>
		 */
		@Override
		public boolean hasChallenge() {
			return ((bitField0_ & 0x00000001) == 0x00000001);
		}

		/**
		 * <code>optional .AuthChallenge challenge = 1;</code>
		 *
		 * <pre>
		 * Request fields
		 * </pre>
		 */
		@Override
		public AuthChallenge getChallenge() {
			return challenge_;
		}

		public static final int RESPONSE_FIELD_NUMBER = 2;
		private CastChannel.AuthResponse response_;

		/**
		 * <code>optional .AuthResponse response = 2;</code>
		 *
		 * <pre>
		 * Response fields
		 * </pre>
		 */
		@Override
		public boolean hasResponse() {
			return ((bitField0_ & 0x00000002) == 0x00000002);
		}

		/**
		 * <code>optional .AuthResponse response = 2;</code>
		 *
		 * <pre>
		 * Response fields
		 * </pre>
		 */
		@Override
		public CastChannel.AuthResponse getResponse() {
			return response_;
		}

		public static final int ERROR_FIELD_NUMBER = 3;
		private CastChannel.AuthError error_;

		/**
		 * <code>optional .AuthError error = 3;</code>
		 */
		@Override
		public boolean hasError() {
			return ((bitField0_ & 0x00000004) == 0x00000004);
		}

		/**
		 * <code>optional .AuthError error = 3;</code>
		 */
		@Override
		public CastChannel.AuthError getError() {
			return error_;
		}

		private void initFields() {
			challenge_ = AuthChallenge.getDefaultInstance();
			response_ = CastChannel.AuthResponse.getDefaultInstance();
			error_ = CastChannel.AuthError.getDefaultInstance();
		}

		private byte memoizedIsInitialized = -1;

		@Override
		public boolean isInitialized() {
			byte isInitialized = memoizedIsInitialized;
			if (isInitialized == 1)
				return true;
			if (isInitialized == 0)
				return false;

			if (hasResponse()) {
				if (!getResponse().isInitialized()) {
					memoizedIsInitialized = 0;
					return false;
				}
			}
			if (hasError()) {
				if (!getError().isInitialized()) {
					memoizedIsInitialized = 0;
					return false;
				}
			}
			memoizedIsInitialized = 1;
			return true;
		}

		@Override
		public void writeTo(CodedOutputStream output) throws IOException {
			getSerializedSize();
			if (((bitField0_ & 0x00000001) == 0x00000001)) {
				output.writeMessage(1, challenge_);
			}
			if (((bitField0_ & 0x00000002) == 0x00000002)) {
				output.writeMessage(2, response_);
			}
			if (((bitField0_ & 0x00000004) == 0x00000004)) {
				output.writeMessage(3, error_);
			}
			output.writeRawBytes(unknownFields);
		}

		private int memoizedSerializedSize = -1;

		@Override
		public int getSerializedSize() {
			int size = memoizedSerializedSize;
			if (size != -1)
				return size;

			size = 0;
			if (((bitField0_ & 0x00000001) == 0x00000001)) {
				size += CodedOutputStream.computeMessageSize(1, challenge_);
			}
			if (((bitField0_ & 0x00000002) == 0x00000002)) {
				size += CodedOutputStream.computeMessageSize(2, response_);
			}
			if (((bitField0_ & 0x00000004) == 0x00000004)) {
				size += CodedOutputStream.computeMessageSize(3, error_);
			}
			size += unknownFields.size();
			memoizedSerializedSize = size;
			return size;
		}

		private static final long serialVersionUID = 0L;

		@Override
		protected Object writeReplace() throws ObjectStreamException {
			return super.writeReplace();
		}

		public static DeviceAuthMessage parseFrom(ByteString data) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static DeviceAuthMessage parseFrom(
			ByteString data,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static DeviceAuthMessage parseFrom(byte[] data) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data);
		}

		public static DeviceAuthMessage parseFrom(
			byte[] data,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(data, extensionRegistry);
		}

		public static DeviceAuthMessage parseFrom(InputStream input) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input);
		}

		public static DeviceAuthMessage parseFrom(
			InputStream input,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input, extensionRegistry);
		}

		public static DeviceAuthMessage parseDelimitedFrom(InputStream input) throws InvalidProtocolBufferException {
			return PARSER.parseDelimitedFrom(input);
		}

		public static DeviceAuthMessage parseDelimitedFrom(
			InputStream input,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseDelimitedFrom(input, extensionRegistry);
		}

		public static DeviceAuthMessage parseFrom(CodedInputStream input) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input);
		}

		public static DeviceAuthMessage parseFrom(
			CodedInputStream input,
			ExtensionRegistryLite extensionRegistry
		) throws InvalidProtocolBufferException {
			return PARSER.parseFrom(input, extensionRegistry);
		}

		public static Builder newBuilder() {
			return Builder.create();
		}

		@Override
		public Builder newBuilderForType() {
			return newBuilder();
		}

		public static Builder newBuilder(DeviceAuthMessage prototype) {
			return newBuilder().mergeFrom(prototype);
		}

		@Override
		public Builder toBuilder() {
			return newBuilder(this);
		}

		/**
		 * Protobuf type
		 * {@code DeviceAuthMessage}
		 */
		public static final class Builder extends
			GeneratedMessageLite.Builder<DeviceAuthMessage, Builder>
			implements
			// @@protoc_insertion_point(builder_implements:DeviceAuthMessage)
			DeviceAuthMessageOrBuilder {

			// Construct using
			// DeviceAuthMessage.newBuilder()
			private Builder() {
				maybeForceBuilderInitialization();
			}

			private void maybeForceBuilderInitialization() {
			}

			private static Builder create() {
				return new Builder();
			}

			@Override
			public Builder clear() {
				super.clear();
				challenge_ = AuthChallenge.getDefaultInstance();
				bitField0_ = (bitField0_ & ~0x00000001);
				response_ = CastChannel.AuthResponse.getDefaultInstance();
				bitField0_ = (bitField0_ & ~0x00000002);
				error_ = CastChannel.AuthError.getDefaultInstance();
				bitField0_ = (bitField0_ & ~0x00000004);
				return this;
			}

			@Override
			public Builder clone() {
				return create().mergeFrom(buildPartial());
			}

			@Override
			public DeviceAuthMessage getDefaultInstanceForType() {
				return DeviceAuthMessage.getDefaultInstance();
			}

			@Override
			public DeviceAuthMessage build() {
				DeviceAuthMessage result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result);
				}
				return result;
			}

			@Override
			public DeviceAuthMessage buildPartial() {
				DeviceAuthMessage result = new DeviceAuthMessage(
					this);
				int from_bitField0_ = bitField0_;
				int to_bitField0_ = 0;
				if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
					to_bitField0_ |= 0x00000001;
				}
				result.challenge_ = challenge_;
				if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
					to_bitField0_ |= 0x00000002;
				}
				result.response_ = response_;
				if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
					to_bitField0_ |= 0x00000004;
				}
				result.error_ = error_;
				result.bitField0_ = to_bitField0_;
				return result;
			}

			@Override
			public Builder mergeFrom(DeviceAuthMessage other) {
				if (other == DeviceAuthMessage.getDefaultInstance())
					return this;
				if (other.hasChallenge()) {
					mergeChallenge(other.getChallenge());
				}
				if (other.hasResponse()) {
					mergeResponse(other.getResponse());
				}
				if (other.hasError()) {
					mergeError(other.getError());
				}
				setUnknownFields(getUnknownFields().concat(other.unknownFields));
				return this;
			}

			@Override
			public boolean isInitialized() {
				if (hasResponse()) {
					if (!getResponse().isInitialized()) {

						return false;
					}
				}
				if (hasError()) {
					if (!getError().isInitialized()) {

						return false;
					}
				}
				return true;
			}

			@Override
			public Builder mergeFrom(
				CodedInputStream input,
				ExtensionRegistryLite extensionRegistry
			) throws InvalidProtocolBufferException {
				DeviceAuthMessage parsedMessage = null;
				try {
					parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
				} catch (InvalidProtocolBufferException e) {
					parsedMessage = (DeviceAuthMessage) e.getUnfinishedMessage();
					throw e;
				} finally {
					if (parsedMessage != null) {
						mergeFrom(parsedMessage);
					}
				}
				return this;
			}

			private int bitField0_;

			private AuthChallenge challenge_ = AuthChallenge
				.getDefaultInstance();

			/**
			 * <code>optional .AuthChallenge challenge = 1;</code>
			 *
			 * <pre>
			 * Request fields
			 * </pre>
			 */
			@Override
			public boolean hasChallenge() {
				return ((bitField0_ & 0x00000001) == 0x00000001);
			}

			/**
			 * <code>optional .AuthChallenge challenge = 1;</code>
			 *
			 * <pre>
			 * Request fields
			 * </pre>
			 */
			@Override
			public AuthChallenge getChallenge() {
				return challenge_;
			}

			/**
			 * <code>optional .AuthChallenge challenge = 1;</code>
			 *
			 * <pre>
			 * Request fields
			 * </pre>
			 */
			public Builder setChallenge(AuthChallenge value) {
				if (value == null) {
					throw new NullPointerException();
				}
				challenge_ = value;

				bitField0_ |= 0x00000001;
				return this;
			}

			/**
			 * <code>optional .AuthChallenge challenge = 1;</code>
			 *
			 * <pre>
			 * Request fields
			 * </pre>
			 */
			public Builder setChallenge(AuthChallenge.Builder builderForValue) {
				challenge_ = builderForValue.build();

				bitField0_ |= 0x00000001;
				return this;
			}

			/**
			 * <code>optional .AuthChallenge challenge = 1;</code>
			 *
			 * <pre>
			 * Request fields
			 * </pre>
			 */
			public Builder mergeChallenge(AuthChallenge value) {
				if (((bitField0_ & 0x00000001) == 0x00000001)
					&& challenge_ != AuthChallenge.getDefaultInstance()) {
					challenge_ = AuthChallenge.newBuilder(challenge_).mergeFrom(value)
						.buildPartial();
				} else {
					challenge_ = value;
				}

				bitField0_ |= 0x00000001;
				return this;
			}

			/**
			 * <code>optional .AuthChallenge challenge = 1;</code>
			 *
			 * <pre>
			 * Request fields
			 * </pre>
			 */
			public Builder clearChallenge() {
				challenge_ = AuthChallenge.getDefaultInstance();

				bitField0_ = (bitField0_ & ~0x00000001);
				return this;
			}

			private CastChannel.AuthResponse response_ = CastChannel.AuthResponse
				.getDefaultInstance();

			/**
			 * <code>optional .AuthResponse response = 2;</code>
			 *
			 * <pre>
			 * Response fields
			 * </pre>
			 */
			@Override
			public boolean hasResponse() {
				return ((bitField0_ & 0x00000002) == 0x00000002);
			}

			/**
			 * <code>optional .AuthResponse response = 2;</code>
			 *
			 * <pre>
			 * Response fields
			 * </pre>
			 */
			@Override
			public CastChannel.AuthResponse getResponse() {
				return response_;
			}

			/**
			 * <code>optional .AuthResponse response = 2;</code>
			 *
			 * <pre>
			 * Response fields
			 * </pre>
			 */
			public Builder setResponse(CastChannel.AuthResponse value) {
				if (value == null) {
					throw new NullPointerException();
				}
				response_ = value;

				bitField0_ |= 0x00000002;
				return this;
			}

			/**
			 * <code>optional .AuthResponse response = 2;</code>
			 *
			 * <pre>
			 * Response fields
			 * </pre>
			 */
			public Builder setResponse(CastChannel.AuthResponse.Builder builderForValue) {
				response_ = builderForValue.build();

				bitField0_ |= 0x00000002;
				return this;
			}

			/**
			 * <code>optional .AuthResponse response = 2;</code>
			 *
			 * <pre>
			 * Response fields
			 * </pre>
			 */
			public Builder mergeResponse(CastChannel.AuthResponse value) {
				if (((bitField0_ & 0x00000002) == 0x00000002)
					&& response_ != CastChannel.AuthResponse.getDefaultInstance()) {
					response_ = CastChannel.AuthResponse.newBuilder(response_).mergeFrom(value)
						.buildPartial();
				} else {
					response_ = value;
				}

				bitField0_ |= 0x00000002;
				return this;
			}

			/**
			 * <code>optional .AuthResponse response = 2;</code>
			 *
			 * <pre>
			 * Response fields
			 * </pre>
			 */
			public Builder clearResponse() {
				response_ = CastChannel.AuthResponse.getDefaultInstance();

				bitField0_ = (bitField0_ & ~0x00000002);
				return this;
			}

			private CastChannel.AuthError error_ = CastChannel.AuthError
				.getDefaultInstance();

			/**
			 * <code>optional .AuthError error = 3;</code>
			 */
			@Override
			public boolean hasError() {
				return ((bitField0_ & 0x00000004) == 0x00000004);
			}

			/**
			 * <code>optional .AuthError error = 3;</code>
			 */
			@Override
			public CastChannel.AuthError getError() {
				return error_;
			}

			/**
			 * <code>optional .AuthError error = 3;</code>
			 */
			public Builder setError(CastChannel.AuthError value) {
				if (value == null) {
					throw new NullPointerException();
				}
				error_ = value;

				bitField0_ |= 0x00000004;
				return this;
			}

			/**
			 * <code>optional .AuthError error = 3;</code>
			 */
			public Builder setError(CastChannel.AuthError.Builder builderForValue) {
				error_ = builderForValue.build();

				bitField0_ |= 0x00000004;
				return this;
			}

			/**
			 * <code>optional .AuthError error = 3;</code>
			 */
			public Builder mergeError(CastChannel.AuthError value) {
				if (((bitField0_ & 0x00000004) == 0x00000004)
					&& error_ != CastChannel.AuthError.getDefaultInstance()) {
					error_ = CastChannel.AuthError.newBuilder(error_).mergeFrom(value).buildPartial();
				} else {
					error_ = value;
				}

				bitField0_ |= 0x00000004;
				return this;
			}

			/**
			 * <code>optional .AuthError error = 3;</code>
			 */
			public Builder clearError() {
				error_ = CastChannel.AuthError.getDefaultInstance();

				bitField0_ = (bitField0_ & ~0x00000004);
				return this;
			}

			// @@protoc_insertion_point(builder_scope:DeviceAuthMessage)
		}

		static {
			defaultInstance = new DeviceAuthMessage(true);
			defaultInstance.initFields();
		}

		// @@protoc_insertion_point(class_scope:DeviceAuthMessage)
	}

	static {
	}

	// @@protoc_insertion_point(outer_class_scope)
}
